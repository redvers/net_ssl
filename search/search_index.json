{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Packages net_ssl","title":"net_ssl"},{"location":"net_ssl--index/","text":"No package doc string provided for net_ssl. Public Types \u00b6 primitive X509 primitive SslAutoVersion primitive Ssl3Version primitive Tls1Version primitive Tls1u1Version primitive Tls1u2Version primitive Tls1u3Version primitive Dtls1Version primitive Dtls1u2Version primitive TlsMinVersion primitive TlsMaxVersion primitive DtlsMinVersion primitive DtlsMaxVersion class SSLContext class SSLConnection primitive SSLHandshake primitive SSLAuthFail primitive SSLReady primitive SSLError type SSLState class SSL interface ALPNProtocolNotify type ALPNProtocolName primitive ALPNFatal primitive ALPNNoAck primitive ALPNWarning type ALPNMatchResult interface ALPNProtocolResolver class ALPNStandardProtocolResolver","title":"Package"},{"location":"net_ssl--index/#public-types","text":"primitive X509 primitive SslAutoVersion primitive Ssl3Version primitive Tls1Version primitive Tls1u1Version primitive Tls1u2Version primitive Tls1u3Version primitive Dtls1Version primitive Dtls1u2Version primitive TlsMinVersion primitive TlsMaxVersion primitive DtlsMinVersion primitive DtlsMaxVersion class SSLContext class SSLConnection primitive SSLHandshake primitive SSLAuthFail primitive SSLReady primitive SSLError type SSLState class SSL interface ALPNProtocolNotify type ALPNProtocolName primitive ALPNFatal primitive ALPNNoAck primitive ALPNWarning type ALPNMatchResult interface ALPNProtocolResolver class ALPNStandardProtocolResolver","title":"Public Types"},{"location":"net_ssl-ALPNFatal/","text":"ALPNFatal \u00b6 [Source] primitive val ALPNFatal Constructors \u00b6 create \u00b6 [Source] new val create() : ALPNFatal val^ Returns \u00b6 ALPNFatal val^ Public Functions \u00b6 eq \u00b6 [Source] fun box eq( that: ALPNFatal val) : Bool val Parameters \u00b6 that: ALPNFatal val Returns \u00b6 Bool val ne \u00b6 [Source] fun box ne( that: ALPNFatal val) : Bool val Parameters \u00b6 that: ALPNFatal val Returns \u00b6 Bool val","title":"primitive ALPNFatal"},{"location":"net_ssl-ALPNFatal/#alpnfatal","text":"[Source] primitive val ALPNFatal","title":"ALPNFatal"},{"location":"net_ssl-ALPNFatal/#constructors","text":"","title":"Constructors"},{"location":"net_ssl-ALPNFatal/#create","text":"[Source] new val create() : ALPNFatal val^","title":"create"},{"location":"net_ssl-ALPNFatal/#returns","text":"ALPNFatal val^","title":"Returns"},{"location":"net_ssl-ALPNFatal/#public-functions","text":"","title":"Public Functions"},{"location":"net_ssl-ALPNFatal/#eq","text":"[Source] fun box eq( that: ALPNFatal val) : Bool val","title":"eq"},{"location":"net_ssl-ALPNFatal/#parameters","text":"that: ALPNFatal val","title":"Parameters"},{"location":"net_ssl-ALPNFatal/#returns_1","text":"Bool val","title":"Returns"},{"location":"net_ssl-ALPNFatal/#ne","text":"[Source] fun box ne( that: ALPNFatal val) : Bool val","title":"ne"},{"location":"net_ssl-ALPNFatal/#parameters_1","text":"that: ALPNFatal val","title":"Parameters"},{"location":"net_ssl-ALPNFatal/#returns_2","text":"Bool val","title":"Returns"},{"location":"net_ssl-ALPNMatchResult/","text":"ALPNMatchResult \u00b6 [Source] type ALPNMatchResult is (String val | ALPNNoAck val | ALPNWarning val | ALPNFatal val) Type Alias For \u00b6 ( String val | ALPNNoAck val | ALPNWarning val | ALPNFatal val)","title":"type ALPNMatchResult"},{"location":"net_ssl-ALPNMatchResult/#alpnmatchresult","text":"[Source] type ALPNMatchResult is (String val | ALPNNoAck val | ALPNWarning val | ALPNFatal val)","title":"ALPNMatchResult"},{"location":"net_ssl-ALPNMatchResult/#type-alias-for","text":"( String val | ALPNNoAck val | ALPNWarning val | ALPNFatal val)","title":"Type Alias For"},{"location":"net_ssl-ALPNNoAck/","text":"ALPNNoAck \u00b6 [Source] primitive val ALPNNoAck Constructors \u00b6 create \u00b6 [Source] new val create() : ALPNNoAck val^ Returns \u00b6 ALPNNoAck val^ Public Functions \u00b6 eq \u00b6 [Source] fun box eq( that: ALPNNoAck val) : Bool val Parameters \u00b6 that: ALPNNoAck val Returns \u00b6 Bool val ne \u00b6 [Source] fun box ne( that: ALPNNoAck val) : Bool val Parameters \u00b6 that: ALPNNoAck val Returns \u00b6 Bool val","title":"primitive ALPNNoAck"},{"location":"net_ssl-ALPNNoAck/#alpnnoack","text":"[Source] primitive val ALPNNoAck","title":"ALPNNoAck"},{"location":"net_ssl-ALPNNoAck/#constructors","text":"","title":"Constructors"},{"location":"net_ssl-ALPNNoAck/#create","text":"[Source] new val create() : ALPNNoAck val^","title":"create"},{"location":"net_ssl-ALPNNoAck/#returns","text":"ALPNNoAck val^","title":"Returns"},{"location":"net_ssl-ALPNNoAck/#public-functions","text":"","title":"Public Functions"},{"location":"net_ssl-ALPNNoAck/#eq","text":"[Source] fun box eq( that: ALPNNoAck val) : Bool val","title":"eq"},{"location":"net_ssl-ALPNNoAck/#parameters","text":"that: ALPNNoAck val","title":"Parameters"},{"location":"net_ssl-ALPNNoAck/#returns_1","text":"Bool val","title":"Returns"},{"location":"net_ssl-ALPNNoAck/#ne","text":"[Source] fun box ne( that: ALPNNoAck val) : Bool val","title":"ne"},{"location":"net_ssl-ALPNNoAck/#parameters_1","text":"that: ALPNNoAck val","title":"Parameters"},{"location":"net_ssl-ALPNNoAck/#returns_2","text":"Bool val","title":"Returns"},{"location":"net_ssl-ALPNProtocolName/","text":"ALPNProtocolName \u00b6 [Source] type ALPNProtocolName is String val Type Alias For \u00b6 String val","title":"type ALPNProtocolName"},{"location":"net_ssl-ALPNProtocolName/#alpnprotocolname","text":"[Source] type ALPNProtocolName is String val","title":"ALPNProtocolName"},{"location":"net_ssl-ALPNProtocolName/#type-alias-for","text":"String val","title":"Type Alias For"},{"location":"net_ssl-ALPNProtocolNotify/","text":"ALPNProtocolNotify \u00b6 [Source] interface ref ALPNProtocolNotify Public Functions \u00b6 alpn_negotiated \u00b6 [Source] fun ref alpn_negotiated( conn: TCPConnection tag, protocol: (String val | None val)) : None val Parameters \u00b6 conn: TCPConnection tag protocol: ( String val | None val) Returns \u00b6 None val","title":"interface ALPNProtocolNotify"},{"location":"net_ssl-ALPNProtocolNotify/#alpnprotocolnotify","text":"[Source] interface ref ALPNProtocolNotify","title":"ALPNProtocolNotify"},{"location":"net_ssl-ALPNProtocolNotify/#public-functions","text":"","title":"Public Functions"},{"location":"net_ssl-ALPNProtocolNotify/#alpn_negotiated","text":"[Source] fun ref alpn_negotiated( conn: TCPConnection tag, protocol: (String val | None val)) : None val","title":"alpn_negotiated"},{"location":"net_ssl-ALPNProtocolNotify/#parameters","text":"conn: TCPConnection tag protocol: ( String val | None val)","title":"Parameters"},{"location":"net_ssl-ALPNProtocolNotify/#returns","text":"None val","title":"Returns"},{"location":"net_ssl-ALPNProtocolResolver/","text":"ALPNProtocolResolver \u00b6 [Source] Controls the protocol name to be chosen for incomming SSLConnections using the ALPN extension. interface box ALPNProtocolResolver Public Functions \u00b6 resolve \u00b6 [Source] fun box resolve( advertised: Array[String val] val) : (String val | ALPNNoAck val | ALPNWarning val | ALPNFatal val) Parameters \u00b6 advertised: Array [ String val] val Returns \u00b6 ( String val | ALPNNoAck val | ALPNWarning val | ALPNFatal val)","title":"interface ALPNProtocolResolver"},{"location":"net_ssl-ALPNProtocolResolver/#alpnprotocolresolver","text":"[Source] Controls the protocol name to be chosen for incomming SSLConnections using the ALPN extension. interface box ALPNProtocolResolver","title":"ALPNProtocolResolver"},{"location":"net_ssl-ALPNProtocolResolver/#public-functions","text":"","title":"Public Functions"},{"location":"net_ssl-ALPNProtocolResolver/#resolve","text":"[Source] fun box resolve( advertised: Array[String val] val) : (String val | ALPNNoAck val | ALPNWarning val | ALPNFatal val)","title":"resolve"},{"location":"net_ssl-ALPNProtocolResolver/#parameters","text":"advertised: Array [ String val] val","title":"Parameters"},{"location":"net_ssl-ALPNProtocolResolver/#returns","text":"( String val | ALPNNoAck val | ALPNWarning val | ALPNFatal val)","title":"Returns"},{"location":"net_ssl-ALPNStandardProtocolResolver/","text":"ALPNStandardProtocolResolver \u00b6 [Source] Implements the standard protocol selection akin to the OpenSSL function SSL_select_next_proto . class val ALPNStandardProtocolResolver is ALPNProtocolResolver box Implements \u00b6 ALPNProtocolResolver box Constructors \u00b6 create \u00b6 [Source] new val create( supported': Array[String val] val, use_client_as_fallback': Bool val = true) : ALPNStandardProtocolResolver val^ Parameters \u00b6 supported': Array [ String val] val use_client_as_fallback': Bool val = true Returns \u00b6 ALPNStandardProtocolResolver val^ Public fields \u00b6 let supported: Array [ String val] val \u00b6 [Source] let use_client_as_fallback: Bool val \u00b6 [Source] Public Functions \u00b6 resolve \u00b6 [Source] fun box resolve( advertised: Array[String val] val) : (String val | ALPNNoAck val | ALPNWarning val | ALPNFatal val) Parameters \u00b6 advertised: Array [ String val] val Returns \u00b6 ( String val | ALPNNoAck val | ALPNWarning val | ALPNFatal val)","title":"class ALPNStandardProtocolResolver"},{"location":"net_ssl-ALPNStandardProtocolResolver/#alpnstandardprotocolresolver","text":"[Source] Implements the standard protocol selection akin to the OpenSSL function SSL_select_next_proto . class val ALPNStandardProtocolResolver is ALPNProtocolResolver box","title":"ALPNStandardProtocolResolver"},{"location":"net_ssl-ALPNStandardProtocolResolver/#implements","text":"ALPNProtocolResolver box","title":"Implements"},{"location":"net_ssl-ALPNStandardProtocolResolver/#constructors","text":"","title":"Constructors"},{"location":"net_ssl-ALPNStandardProtocolResolver/#create","text":"[Source] new val create( supported': Array[String val] val, use_client_as_fallback': Bool val = true) : ALPNStandardProtocolResolver val^","title":"create"},{"location":"net_ssl-ALPNStandardProtocolResolver/#parameters","text":"supported': Array [ String val] val use_client_as_fallback': Bool val = true","title":"Parameters"},{"location":"net_ssl-ALPNStandardProtocolResolver/#returns","text":"ALPNStandardProtocolResolver val^","title":"Returns"},{"location":"net_ssl-ALPNStandardProtocolResolver/#public-fields","text":"","title":"Public fields"},{"location":"net_ssl-ALPNStandardProtocolResolver/#let-supported-arraystring-val-val","text":"[Source]","title":"let supported: Array[String val] val"},{"location":"net_ssl-ALPNStandardProtocolResolver/#let-use_client_as_fallback-bool-val","text":"[Source]","title":"let use_client_as_fallback: Bool val"},{"location":"net_ssl-ALPNStandardProtocolResolver/#public-functions","text":"","title":"Public Functions"},{"location":"net_ssl-ALPNStandardProtocolResolver/#resolve","text":"[Source] fun box resolve( advertised: Array[String val] val) : (String val | ALPNNoAck val | ALPNWarning val | ALPNFatal val)","title":"resolve"},{"location":"net_ssl-ALPNStandardProtocolResolver/#parameters_1","text":"advertised: Array [ String val] val","title":"Parameters"},{"location":"net_ssl-ALPNStandardProtocolResolver/#returns_1","text":"( String val | ALPNNoAck val | ALPNWarning val | ALPNFatal val)","title":"Returns"},{"location":"net_ssl-ALPNWarning/","text":"ALPNWarning \u00b6 [Source] primitive val ALPNWarning Constructors \u00b6 create \u00b6 [Source] new val create() : ALPNWarning val^ Returns \u00b6 ALPNWarning val^ Public Functions \u00b6 eq \u00b6 [Source] fun box eq( that: ALPNWarning val) : Bool val Parameters \u00b6 that: ALPNWarning val Returns \u00b6 Bool val ne \u00b6 [Source] fun box ne( that: ALPNWarning val) : Bool val Parameters \u00b6 that: ALPNWarning val Returns \u00b6 Bool val","title":"primitive ALPNWarning"},{"location":"net_ssl-ALPNWarning/#alpnwarning","text":"[Source] primitive val ALPNWarning","title":"ALPNWarning"},{"location":"net_ssl-ALPNWarning/#constructors","text":"","title":"Constructors"},{"location":"net_ssl-ALPNWarning/#create","text":"[Source] new val create() : ALPNWarning val^","title":"create"},{"location":"net_ssl-ALPNWarning/#returns","text":"ALPNWarning val^","title":"Returns"},{"location":"net_ssl-ALPNWarning/#public-functions","text":"","title":"Public Functions"},{"location":"net_ssl-ALPNWarning/#eq","text":"[Source] fun box eq( that: ALPNWarning val) : Bool val","title":"eq"},{"location":"net_ssl-ALPNWarning/#parameters","text":"that: ALPNWarning val","title":"Parameters"},{"location":"net_ssl-ALPNWarning/#returns_1","text":"Bool val","title":"Returns"},{"location":"net_ssl-ALPNWarning/#ne","text":"[Source] fun box ne( that: ALPNWarning val) : Bool val","title":"ne"},{"location":"net_ssl-ALPNWarning/#parameters_1","text":"that: ALPNWarning val","title":"Parameters"},{"location":"net_ssl-ALPNWarning/#returns_2","text":"Bool val","title":"Returns"},{"location":"net_ssl-Dtls1Version/","text":"Dtls1Version \u00b6 [Source] primitive val Dtls1Version Constructors \u00b6 create \u00b6 [Source] new val create() : Dtls1Version val^ Returns \u00b6 Dtls1Version val^ Public Functions \u00b6 apply \u00b6 [Source] fun val apply() : ULong val Returns \u00b6 ULong val eq \u00b6 [Source] fun box eq( that: Dtls1Version val) : Bool val Parameters \u00b6 that: Dtls1Version val Returns \u00b6 Bool val ne \u00b6 [Source] fun box ne( that: Dtls1Version val) : Bool val Parameters \u00b6 that: Dtls1Version val Returns \u00b6 Bool val","title":"primitive Dtls1Version"},{"location":"net_ssl-Dtls1Version/#dtls1version","text":"[Source] primitive val Dtls1Version","title":"Dtls1Version"},{"location":"net_ssl-Dtls1Version/#constructors","text":"","title":"Constructors"},{"location":"net_ssl-Dtls1Version/#create","text":"[Source] new val create() : Dtls1Version val^","title":"create"},{"location":"net_ssl-Dtls1Version/#returns","text":"Dtls1Version val^","title":"Returns"},{"location":"net_ssl-Dtls1Version/#public-functions","text":"","title":"Public Functions"},{"location":"net_ssl-Dtls1Version/#apply","text":"[Source] fun val apply() : ULong val","title":"apply"},{"location":"net_ssl-Dtls1Version/#returns_1","text":"ULong val","title":"Returns"},{"location":"net_ssl-Dtls1Version/#eq","text":"[Source] fun box eq( that: Dtls1Version val) : Bool val","title":"eq"},{"location":"net_ssl-Dtls1Version/#parameters","text":"that: Dtls1Version val","title":"Parameters"},{"location":"net_ssl-Dtls1Version/#returns_2","text":"Bool val","title":"Returns"},{"location":"net_ssl-Dtls1Version/#ne","text":"[Source] fun box ne( that: Dtls1Version val) : Bool val","title":"ne"},{"location":"net_ssl-Dtls1Version/#parameters_1","text":"that: Dtls1Version val","title":"Parameters"},{"location":"net_ssl-Dtls1Version/#returns_3","text":"Bool val","title":"Returns"},{"location":"net_ssl-Dtls1u2Version/","text":"Dtls1u2Version \u00b6 [Source] primitive val Dtls1u2Version Constructors \u00b6 create \u00b6 [Source] new val create() : Dtls1u2Version val^ Returns \u00b6 Dtls1u2Version val^ Public Functions \u00b6 apply \u00b6 [Source] fun val apply() : ULong val Returns \u00b6 ULong val eq \u00b6 [Source] fun box eq( that: Dtls1u2Version val) : Bool val Parameters \u00b6 that: Dtls1u2Version val Returns \u00b6 Bool val ne \u00b6 [Source] fun box ne( that: Dtls1u2Version val) : Bool val Parameters \u00b6 that: Dtls1u2Version val Returns \u00b6 Bool val","title":"primitive Dtls1u2Version"},{"location":"net_ssl-Dtls1u2Version/#dtls1u2version","text":"[Source] primitive val Dtls1u2Version","title":"Dtls1u2Version"},{"location":"net_ssl-Dtls1u2Version/#constructors","text":"","title":"Constructors"},{"location":"net_ssl-Dtls1u2Version/#create","text":"[Source] new val create() : Dtls1u2Version val^","title":"create"},{"location":"net_ssl-Dtls1u2Version/#returns","text":"Dtls1u2Version val^","title":"Returns"},{"location":"net_ssl-Dtls1u2Version/#public-functions","text":"","title":"Public Functions"},{"location":"net_ssl-Dtls1u2Version/#apply","text":"[Source] fun val apply() : ULong val","title":"apply"},{"location":"net_ssl-Dtls1u2Version/#returns_1","text":"ULong val","title":"Returns"},{"location":"net_ssl-Dtls1u2Version/#eq","text":"[Source] fun box eq( that: Dtls1u2Version val) : Bool val","title":"eq"},{"location":"net_ssl-Dtls1u2Version/#parameters","text":"that: Dtls1u2Version val","title":"Parameters"},{"location":"net_ssl-Dtls1u2Version/#returns_2","text":"Bool val","title":"Returns"},{"location":"net_ssl-Dtls1u2Version/#ne","text":"[Source] fun box ne( that: Dtls1u2Version val) : Bool val","title":"ne"},{"location":"net_ssl-Dtls1u2Version/#parameters_1","text":"that: Dtls1u2Version val","title":"Parameters"},{"location":"net_ssl-Dtls1u2Version/#returns_3","text":"Bool val","title":"Returns"},{"location":"net_ssl-DtlsMaxVersion/","text":"DtlsMaxVersion \u00b6 [Source] primitive val DtlsMaxVersion Constructors \u00b6 create \u00b6 [Source] new val create() : DtlsMaxVersion val^ Returns \u00b6 DtlsMaxVersion val^ Public Functions \u00b6 apply \u00b6 [Source] fun val apply() : ULong val Returns \u00b6 ULong val eq \u00b6 [Source] fun box eq( that: DtlsMaxVersion val) : Bool val Parameters \u00b6 that: DtlsMaxVersion val Returns \u00b6 Bool val ne \u00b6 [Source] fun box ne( that: DtlsMaxVersion val) : Bool val Parameters \u00b6 that: DtlsMaxVersion val Returns \u00b6 Bool val","title":"primitive DtlsMaxVersion"},{"location":"net_ssl-DtlsMaxVersion/#dtlsmaxversion","text":"[Source] primitive val DtlsMaxVersion","title":"DtlsMaxVersion"},{"location":"net_ssl-DtlsMaxVersion/#constructors","text":"","title":"Constructors"},{"location":"net_ssl-DtlsMaxVersion/#create","text":"[Source] new val create() : DtlsMaxVersion val^","title":"create"},{"location":"net_ssl-DtlsMaxVersion/#returns","text":"DtlsMaxVersion val^","title":"Returns"},{"location":"net_ssl-DtlsMaxVersion/#public-functions","text":"","title":"Public Functions"},{"location":"net_ssl-DtlsMaxVersion/#apply","text":"[Source] fun val apply() : ULong val","title":"apply"},{"location":"net_ssl-DtlsMaxVersion/#returns_1","text":"ULong val","title":"Returns"},{"location":"net_ssl-DtlsMaxVersion/#eq","text":"[Source] fun box eq( that: DtlsMaxVersion val) : Bool val","title":"eq"},{"location":"net_ssl-DtlsMaxVersion/#parameters","text":"that: DtlsMaxVersion val","title":"Parameters"},{"location":"net_ssl-DtlsMaxVersion/#returns_2","text":"Bool val","title":"Returns"},{"location":"net_ssl-DtlsMaxVersion/#ne","text":"[Source] fun box ne( that: DtlsMaxVersion val) : Bool val","title":"ne"},{"location":"net_ssl-DtlsMaxVersion/#parameters_1","text":"that: DtlsMaxVersion val","title":"Parameters"},{"location":"net_ssl-DtlsMaxVersion/#returns_3","text":"Bool val","title":"Returns"},{"location":"net_ssl-DtlsMinVersion/","text":"DtlsMinVersion \u00b6 [Source] primitive val DtlsMinVersion Constructors \u00b6 create \u00b6 [Source] new val create() : DtlsMinVersion val^ Returns \u00b6 DtlsMinVersion val^ Public Functions \u00b6 apply \u00b6 [Source] fun val apply() : ULong val Returns \u00b6 ULong val eq \u00b6 [Source] fun box eq( that: DtlsMinVersion val) : Bool val Parameters \u00b6 that: DtlsMinVersion val Returns \u00b6 Bool val ne \u00b6 [Source] fun box ne( that: DtlsMinVersion val) : Bool val Parameters \u00b6 that: DtlsMinVersion val Returns \u00b6 Bool val","title":"primitive DtlsMinVersion"},{"location":"net_ssl-DtlsMinVersion/#dtlsminversion","text":"[Source] primitive val DtlsMinVersion","title":"DtlsMinVersion"},{"location":"net_ssl-DtlsMinVersion/#constructors","text":"","title":"Constructors"},{"location":"net_ssl-DtlsMinVersion/#create","text":"[Source] new val create() : DtlsMinVersion val^","title":"create"},{"location":"net_ssl-DtlsMinVersion/#returns","text":"DtlsMinVersion val^","title":"Returns"},{"location":"net_ssl-DtlsMinVersion/#public-functions","text":"","title":"Public Functions"},{"location":"net_ssl-DtlsMinVersion/#apply","text":"[Source] fun val apply() : ULong val","title":"apply"},{"location":"net_ssl-DtlsMinVersion/#returns_1","text":"ULong val","title":"Returns"},{"location":"net_ssl-DtlsMinVersion/#eq","text":"[Source] fun box eq( that: DtlsMinVersion val) : Bool val","title":"eq"},{"location":"net_ssl-DtlsMinVersion/#parameters","text":"that: DtlsMinVersion val","title":"Parameters"},{"location":"net_ssl-DtlsMinVersion/#returns_2","text":"Bool val","title":"Returns"},{"location":"net_ssl-DtlsMinVersion/#ne","text":"[Source] fun box ne( that: DtlsMinVersion val) : Bool val","title":"ne"},{"location":"net_ssl-DtlsMinVersion/#parameters_1","text":"that: DtlsMinVersion val","title":"Parameters"},{"location":"net_ssl-DtlsMinVersion/#returns_3","text":"Bool val","title":"Returns"},{"location":"net_ssl-SSL/","text":"SSL \u00b6 [Source] An SSL session manages handshakes, encryption and decryption. It is not tied to any transport layer. class ref SSL Public Functions \u00b6 alpn_selected \u00b6 [Source] Get the protocol identifier negotiated via ALPN fun box alpn_selected() : (String val | None val) Returns \u00b6 ( String val | None val) state \u00b6 [Source] Returns the SSL session state. fun box state() : (SSLHandshake val | SSLAuthFail val | SSLReady val | SSLError val) Returns \u00b6 ( SSLHandshake val | SSLAuthFail val | SSLReady val | SSLError val) read \u00b6 [Source] Returns unencrypted bytes to be passed to the application. If expect is non-zero, the number of bytes returned will be exactly expect . If no data (or less than expect bytes) is available, this returns None. fun ref read( expect: USize val = 0) : (Array[U8 val] iso^ | None val) Parameters \u00b6 expect: USize val = 0 Returns \u00b6 ( Array [ U8 val] iso^ | None val) write \u00b6 [Source] When application data is sent, add it to the SSL session. Raises an error if the handshake is not complete. fun ref write( data: (String val | Array[U8 val] val)) : None val ? Parameters \u00b6 data: ( String val | Array [ U8 val] val) Returns \u00b6 None val ? receive \u00b6 [Source] When data is received, add it to the SSL session. fun ref receive( data: (String val | Array[U8 val] val)) : None val Parameters \u00b6 data: ( String val | Array [ U8 val] val) Returns \u00b6 None val can_send \u00b6 [Source] Returns true if there are encrypted bytes to be passed to the destination. fun ref can_send() : Bool val Returns \u00b6 Bool val send \u00b6 [Source] Returns encrypted bytes to be passed to the destination. Raises an error if no data is available. fun ref send() : Array[U8 val] iso^ ? Returns \u00b6 Array [ U8 val] iso^ ? dispose \u00b6 [Source] Dispose of the session. fun ref dispose() : None val Returns \u00b6 None val","title":"class SSL"},{"location":"net_ssl-SSL/#ssl","text":"[Source] An SSL session manages handshakes, encryption and decryption. It is not tied to any transport layer. class ref SSL","title":"SSL"},{"location":"net_ssl-SSL/#public-functions","text":"","title":"Public Functions"},{"location":"net_ssl-SSL/#alpn_selected","text":"[Source] Get the protocol identifier negotiated via ALPN fun box alpn_selected() : (String val | None val)","title":"alpn_selected"},{"location":"net_ssl-SSL/#returns","text":"( String val | None val)","title":"Returns"},{"location":"net_ssl-SSL/#state","text":"[Source] Returns the SSL session state. fun box state() : (SSLHandshake val | SSLAuthFail val | SSLReady val | SSLError val)","title":"state"},{"location":"net_ssl-SSL/#returns_1","text":"( SSLHandshake val | SSLAuthFail val | SSLReady val | SSLError val)","title":"Returns"},{"location":"net_ssl-SSL/#read","text":"[Source] Returns unencrypted bytes to be passed to the application. If expect is non-zero, the number of bytes returned will be exactly expect . If no data (or less than expect bytes) is available, this returns None. fun ref read( expect: USize val = 0) : (Array[U8 val] iso^ | None val)","title":"read"},{"location":"net_ssl-SSL/#parameters","text":"expect: USize val = 0","title":"Parameters"},{"location":"net_ssl-SSL/#returns_2","text":"( Array [ U8 val] iso^ | None val)","title":"Returns"},{"location":"net_ssl-SSL/#write","text":"[Source] When application data is sent, add it to the SSL session. Raises an error if the handshake is not complete. fun ref write( data: (String val | Array[U8 val] val)) : None val ?","title":"write"},{"location":"net_ssl-SSL/#parameters_1","text":"data: ( String val | Array [ U8 val] val)","title":"Parameters"},{"location":"net_ssl-SSL/#returns_3","text":"None val ?","title":"Returns"},{"location":"net_ssl-SSL/#receive","text":"[Source] When data is received, add it to the SSL session. fun ref receive( data: (String val | Array[U8 val] val)) : None val","title":"receive"},{"location":"net_ssl-SSL/#parameters_2","text":"data: ( String val | Array [ U8 val] val)","title":"Parameters"},{"location":"net_ssl-SSL/#returns_4","text":"None val","title":"Returns"},{"location":"net_ssl-SSL/#can_send","text":"[Source] Returns true if there are encrypted bytes to be passed to the destination. fun ref can_send() : Bool val","title":"can_send"},{"location":"net_ssl-SSL/#returns_5","text":"Bool val","title":"Returns"},{"location":"net_ssl-SSL/#send","text":"[Source] Returns encrypted bytes to be passed to the destination. Raises an error if no data is available. fun ref send() : Array[U8 val] iso^ ?","title":"send"},{"location":"net_ssl-SSL/#returns_6","text":"Array [ U8 val] iso^ ?","title":"Returns"},{"location":"net_ssl-SSL/#dispose","text":"[Source] Dispose of the session. fun ref dispose() : None val","title":"dispose"},{"location":"net_ssl-SSL/#returns_7","text":"None val","title":"Returns"},{"location":"net_ssl-SSLAuthFail/","text":"SSLAuthFail \u00b6 [Source] primitive val SSLAuthFail Constructors \u00b6 create \u00b6 [Source] new val create() : SSLAuthFail val^ Returns \u00b6 SSLAuthFail val^ Public Functions \u00b6 eq \u00b6 [Source] fun box eq( that: SSLAuthFail val) : Bool val Parameters \u00b6 that: SSLAuthFail val Returns \u00b6 Bool val ne \u00b6 [Source] fun box ne( that: SSLAuthFail val) : Bool val Parameters \u00b6 that: SSLAuthFail val Returns \u00b6 Bool val","title":"primitive SSLAuthFail"},{"location":"net_ssl-SSLAuthFail/#sslauthfail","text":"[Source] primitive val SSLAuthFail","title":"SSLAuthFail"},{"location":"net_ssl-SSLAuthFail/#constructors","text":"","title":"Constructors"},{"location":"net_ssl-SSLAuthFail/#create","text":"[Source] new val create() : SSLAuthFail val^","title":"create"},{"location":"net_ssl-SSLAuthFail/#returns","text":"SSLAuthFail val^","title":"Returns"},{"location":"net_ssl-SSLAuthFail/#public-functions","text":"","title":"Public Functions"},{"location":"net_ssl-SSLAuthFail/#eq","text":"[Source] fun box eq( that: SSLAuthFail val) : Bool val","title":"eq"},{"location":"net_ssl-SSLAuthFail/#parameters","text":"that: SSLAuthFail val","title":"Parameters"},{"location":"net_ssl-SSLAuthFail/#returns_1","text":"Bool val","title":"Returns"},{"location":"net_ssl-SSLAuthFail/#ne","text":"[Source] fun box ne( that: SSLAuthFail val) : Bool val","title":"ne"},{"location":"net_ssl-SSLAuthFail/#parameters_1","text":"that: SSLAuthFail val","title":"Parameters"},{"location":"net_ssl-SSLAuthFail/#returns_2","text":"Bool val","title":"Returns"},{"location":"net_ssl-SSLConnection/","text":"SSLConnection \u00b6 [Source] Wrap another protocol in an SSL connection. class ref SSLConnection is TCPConnectionNotify ref Implements \u00b6 TCPConnectionNotify ref Constructors \u00b6 create \u00b6 [Source] Initialise with a wrapped protocol and an SSL session. new iso create( notify: TCPConnectionNotify iso, ssl: SSL iso) : SSLConnection iso^ Parameters \u00b6 notify: TCPConnectionNotify iso ssl: SSL iso Returns \u00b6 SSLConnection iso^ Public Functions \u00b6 accepted \u00b6 [Source] Swallow this event until the handshake is complete. fun ref accepted( conn: TCPConnection ref) : None val Parameters \u00b6 conn: TCPConnection ref Returns \u00b6 None val connecting \u00b6 [Source] Forward to the wrapped protocol. fun ref connecting( conn: TCPConnection ref, count: U32 val) : None val Parameters \u00b6 conn: TCPConnection ref count: U32 val Returns \u00b6 None val connected \u00b6 [Source] Swallow this event until the handshake is complete. fun ref connected( conn: TCPConnection ref) : None val Parameters \u00b6 conn: TCPConnection ref Returns \u00b6 None val connect_failed \u00b6 [Source] Forward to the wrapped protocol. fun ref connect_failed( conn: TCPConnection ref) : None val Parameters \u00b6 conn: TCPConnection ref Returns \u00b6 None val sent \u00b6 [Source] Pass the data to the SSL session and check for both new application data and new destination data. fun ref sent( conn: TCPConnection ref, data: (String val | Array[U8 val] val)) : (String val | Array[U8 val] val) Parameters \u00b6 conn: TCPConnection ref data: ( String val | Array [ U8 val] val) Returns \u00b6 ( String val | Array [ U8 val] val) sentv \u00b6 [Source] fun ref sentv( conn: TCPConnection ref, data: ByteSeqIter val) : ByteSeqIter val Parameters \u00b6 conn: TCPConnection ref data: ByteSeqIter val Returns \u00b6 ByteSeqIter val received \u00b6 [Source] Pass the data to the SSL session and check for both new application data and new destination data. fun ref received( conn: TCPConnection ref, data: Array[U8 val] iso, times: USize val) : Bool val Parameters \u00b6 conn: TCPConnection ref data: Array [ U8 val] iso times: USize val Returns \u00b6 Bool val expect \u00b6 [Source] Keep track of the expect count for the wrapped protocol. Always tell the TCPConnection to read all available data. fun ref expect( conn: TCPConnection ref, qty: USize val) : USize val Parameters \u00b6 conn: TCPConnection ref qty: USize val Returns \u00b6 USize val closed \u00b6 [Source] Forward to the wrapped protocol. fun ref closed( conn: TCPConnection ref) : None val Parameters \u00b6 conn: TCPConnection ref Returns \u00b6 None val throttled \u00b6 [Source] Forward to the wrapped protocol. fun ref throttled( conn: TCPConnection ref) : None val Parameters \u00b6 conn: TCPConnection ref Returns \u00b6 None val unthrottled \u00b6 [Source] Forward to the wrapped protocol. fun ref unthrottled( conn: TCPConnection ref) : None val Parameters \u00b6 conn: TCPConnection ref Returns \u00b6 None val proxy_via \u00b6 fun ref proxy_via( host: String val, service: String val) : (String val , String val) Parameters \u00b6 host: String val service: String val Returns \u00b6 ( String val , String val) auth_failed \u00b6 fun ref auth_failed( conn: TCPConnection ref) : None val Parameters \u00b6 conn: TCPConnection ref Returns \u00b6 None val","title":"class SSLConnection"},{"location":"net_ssl-SSLConnection/#sslconnection","text":"[Source] Wrap another protocol in an SSL connection. class ref SSLConnection is TCPConnectionNotify ref","title":"SSLConnection"},{"location":"net_ssl-SSLConnection/#implements","text":"TCPConnectionNotify ref","title":"Implements"},{"location":"net_ssl-SSLConnection/#constructors","text":"","title":"Constructors"},{"location":"net_ssl-SSLConnection/#create","text":"[Source] Initialise with a wrapped protocol and an SSL session. new iso create( notify: TCPConnectionNotify iso, ssl: SSL iso) : SSLConnection iso^","title":"create"},{"location":"net_ssl-SSLConnection/#parameters","text":"notify: TCPConnectionNotify iso ssl: SSL iso","title":"Parameters"},{"location":"net_ssl-SSLConnection/#returns","text":"SSLConnection iso^","title":"Returns"},{"location":"net_ssl-SSLConnection/#public-functions","text":"","title":"Public Functions"},{"location":"net_ssl-SSLConnection/#accepted","text":"[Source] Swallow this event until the handshake is complete. fun ref accepted( conn: TCPConnection ref) : None val","title":"accepted"},{"location":"net_ssl-SSLConnection/#parameters_1","text":"conn: TCPConnection ref","title":"Parameters"},{"location":"net_ssl-SSLConnection/#returns_1","text":"None val","title":"Returns"},{"location":"net_ssl-SSLConnection/#connecting","text":"[Source] Forward to the wrapped protocol. fun ref connecting( conn: TCPConnection ref, count: U32 val) : None val","title":"connecting"},{"location":"net_ssl-SSLConnection/#parameters_2","text":"conn: TCPConnection ref count: U32 val","title":"Parameters"},{"location":"net_ssl-SSLConnection/#returns_2","text":"None val","title":"Returns"},{"location":"net_ssl-SSLConnection/#connected","text":"[Source] Swallow this event until the handshake is complete. fun ref connected( conn: TCPConnection ref) : None val","title":"connected"},{"location":"net_ssl-SSLConnection/#parameters_3","text":"conn: TCPConnection ref","title":"Parameters"},{"location":"net_ssl-SSLConnection/#returns_3","text":"None val","title":"Returns"},{"location":"net_ssl-SSLConnection/#connect_failed","text":"[Source] Forward to the wrapped protocol. fun ref connect_failed( conn: TCPConnection ref) : None val","title":"connect_failed"},{"location":"net_ssl-SSLConnection/#parameters_4","text":"conn: TCPConnection ref","title":"Parameters"},{"location":"net_ssl-SSLConnection/#returns_4","text":"None val","title":"Returns"},{"location":"net_ssl-SSLConnection/#sent","text":"[Source] Pass the data to the SSL session and check for both new application data and new destination data. fun ref sent( conn: TCPConnection ref, data: (String val | Array[U8 val] val)) : (String val | Array[U8 val] val)","title":"sent"},{"location":"net_ssl-SSLConnection/#parameters_5","text":"conn: TCPConnection ref data: ( String val | Array [ U8 val] val)","title":"Parameters"},{"location":"net_ssl-SSLConnection/#returns_5","text":"( String val | Array [ U8 val] val)","title":"Returns"},{"location":"net_ssl-SSLConnection/#sentv","text":"[Source] fun ref sentv( conn: TCPConnection ref, data: ByteSeqIter val) : ByteSeqIter val","title":"sentv"},{"location":"net_ssl-SSLConnection/#parameters_6","text":"conn: TCPConnection ref data: ByteSeqIter val","title":"Parameters"},{"location":"net_ssl-SSLConnection/#returns_6","text":"ByteSeqIter val","title":"Returns"},{"location":"net_ssl-SSLConnection/#received","text":"[Source] Pass the data to the SSL session and check for both new application data and new destination data. fun ref received( conn: TCPConnection ref, data: Array[U8 val] iso, times: USize val) : Bool val","title":"received"},{"location":"net_ssl-SSLConnection/#parameters_7","text":"conn: TCPConnection ref data: Array [ U8 val] iso times: USize val","title":"Parameters"},{"location":"net_ssl-SSLConnection/#returns_7","text":"Bool val","title":"Returns"},{"location":"net_ssl-SSLConnection/#expect","text":"[Source] Keep track of the expect count for the wrapped protocol. Always tell the TCPConnection to read all available data. fun ref expect( conn: TCPConnection ref, qty: USize val) : USize val","title":"expect"},{"location":"net_ssl-SSLConnection/#parameters_8","text":"conn: TCPConnection ref qty: USize val","title":"Parameters"},{"location":"net_ssl-SSLConnection/#returns_8","text":"USize val","title":"Returns"},{"location":"net_ssl-SSLConnection/#closed","text":"[Source] Forward to the wrapped protocol. fun ref closed( conn: TCPConnection ref) : None val","title":"closed"},{"location":"net_ssl-SSLConnection/#parameters_9","text":"conn: TCPConnection ref","title":"Parameters"},{"location":"net_ssl-SSLConnection/#returns_9","text":"None val","title":"Returns"},{"location":"net_ssl-SSLConnection/#throttled","text":"[Source] Forward to the wrapped protocol. fun ref throttled( conn: TCPConnection ref) : None val","title":"throttled"},{"location":"net_ssl-SSLConnection/#parameters_10","text":"conn: TCPConnection ref","title":"Parameters"},{"location":"net_ssl-SSLConnection/#returns_10","text":"None val","title":"Returns"},{"location":"net_ssl-SSLConnection/#unthrottled","text":"[Source] Forward to the wrapped protocol. fun ref unthrottled( conn: TCPConnection ref) : None val","title":"unthrottled"},{"location":"net_ssl-SSLConnection/#parameters_11","text":"conn: TCPConnection ref","title":"Parameters"},{"location":"net_ssl-SSLConnection/#returns_11","text":"None val","title":"Returns"},{"location":"net_ssl-SSLConnection/#proxy_via","text":"fun ref proxy_via( host: String val, service: String val) : (String val , String val)","title":"proxy_via"},{"location":"net_ssl-SSLConnection/#parameters_12","text":"host: String val service: String val","title":"Parameters"},{"location":"net_ssl-SSLConnection/#returns_12","text":"( String val , String val)","title":"Returns"},{"location":"net_ssl-SSLConnection/#auth_failed","text":"fun ref auth_failed( conn: TCPConnection ref) : None val","title":"auth_failed"},{"location":"net_ssl-SSLConnection/#parameters_13","text":"conn: TCPConnection ref","title":"Parameters"},{"location":"net_ssl-SSLConnection/#returns_13","text":"None val","title":"Returns"},{"location":"net_ssl-SSLContext/","text":"SSLContext \u00b6 [Source] An SSL context is used to create SSL sessions. class val SSLContext Constructors \u00b6 create \u00b6 [Source] Create an SSL context. new ref create() : SSLContext ref^ Returns \u00b6 SSLContext ref^ Public Functions \u00b6 client \u00b6 [Source] Create a client-side SSL session. If a hostname is supplied, the server side certificate must be valid for that hostname. fun box client( hostname: String val = \"\") : SSL iso^ ? Parameters \u00b6 hostname: String val = \"\" Returns \u00b6 SSL iso^ ? server \u00b6 [Source] Create a server-side SSL session. fun box server() : SSL iso^ ? Returns \u00b6 SSL iso^ ? set_cert \u00b6 [Source] The cert file is a PEM certificate chain. The key file is a private key. Servers must set this. For clients, it is optional. fun ref set_cert( cert: FilePath val, key: FilePath val) : None val ? Parameters \u00b6 cert: FilePath val key: FilePath val Returns \u00b6 None val ? set_authority \u00b6 [Source] Use a PEM file and/or a directory of PEM files to specify certificate authorities. Clients must set this. For servers, it is optional. Use None to indicate no file or no path. Raises an error if these verify locations aren't valid. If both file and path are None , on Windows this method loads the system root certificates. On Posix it raises an error. fun ref set_authority( file: (FilePath val | None val), path: (FilePath val | None val) = reference) : None val ? Parameters \u00b6 file: ( FilePath val | None val) path: ( FilePath val | None val) = reference Returns \u00b6 None val ? set_ciphers \u00b6 [Source] Set the accepted ciphers. This replaces the existing list. Raises an error if the cipher list is invalid. fun ref set_ciphers( ciphers: String val) : None val ? Parameters \u00b6 ciphers: String val Returns \u00b6 None val ? set_client_verify \u00b6 [Source] Set to true to require verification. Defaults to true. fun ref set_client_verify( state: Bool val) : None val Parameters \u00b6 state: Bool val Returns \u00b6 None val set_server_verify \u00b6 [Source] Set to true to require verification. Defaults to false. fun ref set_server_verify( state: Bool val) : None val Parameters \u00b6 state: Bool val Returns \u00b6 None val set_verify_depth \u00b6 [Source] Set the verify depth. Defaults to 6. fun ref set_verify_depth( depth: U32 val) : None val Parameters \u00b6 depth: U32 val Returns \u00b6 None val set_min_proto_version \u00b6 [Source] Set minimum protocol version. Set to SslAutoVersion, 0, to automatically manage lowest version. Supported versions: Ssl3Version, Tls1Version, Tls1u1Version, Tls1u2Version, Tls1u3Version, Dtls1Version, Dtls1u2Version fun ref set_min_proto_version( version: ULong val) : None val ? Parameters \u00b6 version: ULong val Returns \u00b6 None val ? get_min_proto_version \u00b6 [Source] Get minimum protocol version. Returns SslAutoVersion, 0, when automatically managing lowest version. Supported versions: Ssl3Version, Tls1Version, Tls1u1Version, Tls1u2Version, Tls1u3Version, Dtls1Version, Dtls1u2Version fun ref get_min_proto_version() : ILong val Returns \u00b6 ILong val set_max_proto_version \u00b6 [Source] Set maximum protocol version. Set to SslAutoVersion, 0, to automatically manage higest version. Supported versions: Ssl3Version, Tls1Version, Tls1u1Version, Tls1u2Version, Tls1u3Version, Dtls1Version, Dtls1u2Version fun ref set_max_proto_version( version: ULong val) : None val ? Parameters \u00b6 version: ULong val Returns \u00b6 None val ? get_max_proto_version \u00b6 [Source] Get maximum protocol version. Returns SslAutoVersion, 0, when automatically managing highest version. Supported versions: Ssl3Version, Tls1Version, Tls1u1Version, Tls1u2Version, Tls1u3Version, Dtls1Version, Dtls1u2Version fun ref get_max_proto_version() : ILong val Returns \u00b6 ILong val alpn_set_resolver \u00b6 [Source] Use resolver to choose the protocol to be selected for incomming connections. Returns true on success Requires OpenSSL >= 1.0.2 fun ref alpn_set_resolver( resolver: ALPNProtocolResolver box) : Bool val Parameters \u00b6 resolver: ALPNProtocolResolver box Returns \u00b6 Bool val alpn_set_client_protocols \u00b6 [Source] Configures the SSLContext to advertise the protocol names defined in protocols when connecting to a server protocol names must have a size of 1 to 255 Returns true on success Requires OpenSSL >= 1.0.2 fun ref alpn_set_client_protocols( protocols: Array[String val] box) : Bool val Parameters \u00b6 protocols: Array [ String val] box Returns \u00b6 Bool val allow_tls_v1 \u00b6 [Source] Allow TLS v1. Defaults to false. Deprecated: use set_min_proto_version and set_max_proto_version fun ref allow_tls_v1( state: Bool val) : None val Parameters \u00b6 state: Bool val Returns \u00b6 None val allow_tls_v1_1 \u00b6 [Source] Allow TLS v1.1. Defaults to false. Deprecated: use set_min_proto_version and set_max_proto_version fun ref allow_tls_v1_1( state: Bool val) : None val Parameters \u00b6 state: Bool val Returns \u00b6 None val allow_tls_v1_2 \u00b6 [Source] Allow TLS v1.2. Defaults to true. Deprecated: use set_min_proto_version and set_max_proto_version fun ref allow_tls_v1_2( state: Bool val) : None val Parameters \u00b6 state: Bool val Returns \u00b6 None val dispose \u00b6 [Source] Free the SSL context. fun ref dispose() : None val Returns \u00b6 None val","title":"class SSLContext"},{"location":"net_ssl-SSLContext/#sslcontext","text":"[Source] An SSL context is used to create SSL sessions. class val SSLContext","title":"SSLContext"},{"location":"net_ssl-SSLContext/#constructors","text":"","title":"Constructors"},{"location":"net_ssl-SSLContext/#create","text":"[Source] Create an SSL context. new ref create() : SSLContext ref^","title":"create"},{"location":"net_ssl-SSLContext/#returns","text":"SSLContext ref^","title":"Returns"},{"location":"net_ssl-SSLContext/#public-functions","text":"","title":"Public Functions"},{"location":"net_ssl-SSLContext/#client","text":"[Source] Create a client-side SSL session. If a hostname is supplied, the server side certificate must be valid for that hostname. fun box client( hostname: String val = \"\") : SSL iso^ ?","title":"client"},{"location":"net_ssl-SSLContext/#parameters","text":"hostname: String val = \"\"","title":"Parameters"},{"location":"net_ssl-SSLContext/#returns_1","text":"SSL iso^ ?","title":"Returns"},{"location":"net_ssl-SSLContext/#server","text":"[Source] Create a server-side SSL session. fun box server() : SSL iso^ ?","title":"server"},{"location":"net_ssl-SSLContext/#returns_2","text":"SSL iso^ ?","title":"Returns"},{"location":"net_ssl-SSLContext/#set_cert","text":"[Source] The cert file is a PEM certificate chain. The key file is a private key. Servers must set this. For clients, it is optional. fun ref set_cert( cert: FilePath val, key: FilePath val) : None val ?","title":"set_cert"},{"location":"net_ssl-SSLContext/#parameters_1","text":"cert: FilePath val key: FilePath val","title":"Parameters"},{"location":"net_ssl-SSLContext/#returns_3","text":"None val ?","title":"Returns"},{"location":"net_ssl-SSLContext/#set_authority","text":"[Source] Use a PEM file and/or a directory of PEM files to specify certificate authorities. Clients must set this. For servers, it is optional. Use None to indicate no file or no path. Raises an error if these verify locations aren't valid. If both file and path are None , on Windows this method loads the system root certificates. On Posix it raises an error. fun ref set_authority( file: (FilePath val | None val), path: (FilePath val | None val) = reference) : None val ?","title":"set_authority"},{"location":"net_ssl-SSLContext/#parameters_2","text":"file: ( FilePath val | None val) path: ( FilePath val | None val) = reference","title":"Parameters"},{"location":"net_ssl-SSLContext/#returns_4","text":"None val ?","title":"Returns"},{"location":"net_ssl-SSLContext/#set_ciphers","text":"[Source] Set the accepted ciphers. This replaces the existing list. Raises an error if the cipher list is invalid. fun ref set_ciphers( ciphers: String val) : None val ?","title":"set_ciphers"},{"location":"net_ssl-SSLContext/#parameters_3","text":"ciphers: String val","title":"Parameters"},{"location":"net_ssl-SSLContext/#returns_5","text":"None val ?","title":"Returns"},{"location":"net_ssl-SSLContext/#set_client_verify","text":"[Source] Set to true to require verification. Defaults to true. fun ref set_client_verify( state: Bool val) : None val","title":"set_client_verify"},{"location":"net_ssl-SSLContext/#parameters_4","text":"state: Bool val","title":"Parameters"},{"location":"net_ssl-SSLContext/#returns_6","text":"None val","title":"Returns"},{"location":"net_ssl-SSLContext/#set_server_verify","text":"[Source] Set to true to require verification. Defaults to false. fun ref set_server_verify( state: Bool val) : None val","title":"set_server_verify"},{"location":"net_ssl-SSLContext/#parameters_5","text":"state: Bool val","title":"Parameters"},{"location":"net_ssl-SSLContext/#returns_7","text":"None val","title":"Returns"},{"location":"net_ssl-SSLContext/#set_verify_depth","text":"[Source] Set the verify depth. Defaults to 6. fun ref set_verify_depth( depth: U32 val) : None val","title":"set_verify_depth"},{"location":"net_ssl-SSLContext/#parameters_6","text":"depth: U32 val","title":"Parameters"},{"location":"net_ssl-SSLContext/#returns_8","text":"None val","title":"Returns"},{"location":"net_ssl-SSLContext/#set_min_proto_version","text":"[Source] Set minimum protocol version. Set to SslAutoVersion, 0, to automatically manage lowest version. Supported versions: Ssl3Version, Tls1Version, Tls1u1Version, Tls1u2Version, Tls1u3Version, Dtls1Version, Dtls1u2Version fun ref set_min_proto_version( version: ULong val) : None val ?","title":"set_min_proto_version"},{"location":"net_ssl-SSLContext/#parameters_7","text":"version: ULong val","title":"Parameters"},{"location":"net_ssl-SSLContext/#returns_9","text":"None val ?","title":"Returns"},{"location":"net_ssl-SSLContext/#get_min_proto_version","text":"[Source] Get minimum protocol version. Returns SslAutoVersion, 0, when automatically managing lowest version. Supported versions: Ssl3Version, Tls1Version, Tls1u1Version, Tls1u2Version, Tls1u3Version, Dtls1Version, Dtls1u2Version fun ref get_min_proto_version() : ILong val","title":"get_min_proto_version"},{"location":"net_ssl-SSLContext/#returns_10","text":"ILong val","title":"Returns"},{"location":"net_ssl-SSLContext/#set_max_proto_version","text":"[Source] Set maximum protocol version. Set to SslAutoVersion, 0, to automatically manage higest version. Supported versions: Ssl3Version, Tls1Version, Tls1u1Version, Tls1u2Version, Tls1u3Version, Dtls1Version, Dtls1u2Version fun ref set_max_proto_version( version: ULong val) : None val ?","title":"set_max_proto_version"},{"location":"net_ssl-SSLContext/#parameters_8","text":"version: ULong val","title":"Parameters"},{"location":"net_ssl-SSLContext/#returns_11","text":"None val ?","title":"Returns"},{"location":"net_ssl-SSLContext/#get_max_proto_version","text":"[Source] Get maximum protocol version. Returns SslAutoVersion, 0, when automatically managing highest version. Supported versions: Ssl3Version, Tls1Version, Tls1u1Version, Tls1u2Version, Tls1u3Version, Dtls1Version, Dtls1u2Version fun ref get_max_proto_version() : ILong val","title":"get_max_proto_version"},{"location":"net_ssl-SSLContext/#returns_12","text":"ILong val","title":"Returns"},{"location":"net_ssl-SSLContext/#alpn_set_resolver","text":"[Source] Use resolver to choose the protocol to be selected for incomming connections. Returns true on success Requires OpenSSL >= 1.0.2 fun ref alpn_set_resolver( resolver: ALPNProtocolResolver box) : Bool val","title":"alpn_set_resolver"},{"location":"net_ssl-SSLContext/#parameters_9","text":"resolver: ALPNProtocolResolver box","title":"Parameters"},{"location":"net_ssl-SSLContext/#returns_13","text":"Bool val","title":"Returns"},{"location":"net_ssl-SSLContext/#alpn_set_client_protocols","text":"[Source] Configures the SSLContext to advertise the protocol names defined in protocols when connecting to a server protocol names must have a size of 1 to 255 Returns true on success Requires OpenSSL >= 1.0.2 fun ref alpn_set_client_protocols( protocols: Array[String val] box) : Bool val","title":"alpn_set_client_protocols"},{"location":"net_ssl-SSLContext/#parameters_10","text":"protocols: Array [ String val] box","title":"Parameters"},{"location":"net_ssl-SSLContext/#returns_14","text":"Bool val","title":"Returns"},{"location":"net_ssl-SSLContext/#allow_tls_v1","text":"[Source] Allow TLS v1. Defaults to false. Deprecated: use set_min_proto_version and set_max_proto_version fun ref allow_tls_v1( state: Bool val) : None val","title":"allow_tls_v1"},{"location":"net_ssl-SSLContext/#parameters_11","text":"state: Bool val","title":"Parameters"},{"location":"net_ssl-SSLContext/#returns_15","text":"None val","title":"Returns"},{"location":"net_ssl-SSLContext/#allow_tls_v1_1","text":"[Source] Allow TLS v1.1. Defaults to false. Deprecated: use set_min_proto_version and set_max_proto_version fun ref allow_tls_v1_1( state: Bool val) : None val","title":"allow_tls_v1_1"},{"location":"net_ssl-SSLContext/#parameters_12","text":"state: Bool val","title":"Parameters"},{"location":"net_ssl-SSLContext/#returns_16","text":"None val","title":"Returns"},{"location":"net_ssl-SSLContext/#allow_tls_v1_2","text":"[Source] Allow TLS v1.2. Defaults to true. Deprecated: use set_min_proto_version and set_max_proto_version fun ref allow_tls_v1_2( state: Bool val) : None val","title":"allow_tls_v1_2"},{"location":"net_ssl-SSLContext/#parameters_13","text":"state: Bool val","title":"Parameters"},{"location":"net_ssl-SSLContext/#returns_17","text":"None val","title":"Returns"},{"location":"net_ssl-SSLContext/#dispose","text":"[Source] Free the SSL context. fun ref dispose() : None val","title":"dispose"},{"location":"net_ssl-SSLContext/#returns_18","text":"None val","title":"Returns"},{"location":"net_ssl-SSLError/","text":"SSLError \u00b6 [Source] primitive val SSLError Constructors \u00b6 create \u00b6 [Source] new val create() : SSLError val^ Returns \u00b6 SSLError val^ Public Functions \u00b6 eq \u00b6 [Source] fun box eq( that: SSLError val) : Bool val Parameters \u00b6 that: SSLError val Returns \u00b6 Bool val ne \u00b6 [Source] fun box ne( that: SSLError val) : Bool val Parameters \u00b6 that: SSLError val Returns \u00b6 Bool val","title":"primitive SSLError"},{"location":"net_ssl-SSLError/#sslerror","text":"[Source] primitive val SSLError","title":"SSLError"},{"location":"net_ssl-SSLError/#constructors","text":"","title":"Constructors"},{"location":"net_ssl-SSLError/#create","text":"[Source] new val create() : SSLError val^","title":"create"},{"location":"net_ssl-SSLError/#returns","text":"SSLError val^","title":"Returns"},{"location":"net_ssl-SSLError/#public-functions","text":"","title":"Public Functions"},{"location":"net_ssl-SSLError/#eq","text":"[Source] fun box eq( that: SSLError val) : Bool val","title":"eq"},{"location":"net_ssl-SSLError/#parameters","text":"that: SSLError val","title":"Parameters"},{"location":"net_ssl-SSLError/#returns_1","text":"Bool val","title":"Returns"},{"location":"net_ssl-SSLError/#ne","text":"[Source] fun box ne( that: SSLError val) : Bool val","title":"ne"},{"location":"net_ssl-SSLError/#parameters_1","text":"that: SSLError val","title":"Parameters"},{"location":"net_ssl-SSLError/#returns_2","text":"Bool val","title":"Returns"},{"location":"net_ssl-SSLHandshake/","text":"SSLHandshake \u00b6 [Source] primitive val SSLHandshake Constructors \u00b6 create \u00b6 [Source] new val create() : SSLHandshake val^ Returns \u00b6 SSLHandshake val^ Public Functions \u00b6 eq \u00b6 [Source] fun box eq( that: SSLHandshake val) : Bool val Parameters \u00b6 that: SSLHandshake val Returns \u00b6 Bool val ne \u00b6 [Source] fun box ne( that: SSLHandshake val) : Bool val Parameters \u00b6 that: SSLHandshake val Returns \u00b6 Bool val","title":"primitive SSLHandshake"},{"location":"net_ssl-SSLHandshake/#sslhandshake","text":"[Source] primitive val SSLHandshake","title":"SSLHandshake"},{"location":"net_ssl-SSLHandshake/#constructors","text":"","title":"Constructors"},{"location":"net_ssl-SSLHandshake/#create","text":"[Source] new val create() : SSLHandshake val^","title":"create"},{"location":"net_ssl-SSLHandshake/#returns","text":"SSLHandshake val^","title":"Returns"},{"location":"net_ssl-SSLHandshake/#public-functions","text":"","title":"Public Functions"},{"location":"net_ssl-SSLHandshake/#eq","text":"[Source] fun box eq( that: SSLHandshake val) : Bool val","title":"eq"},{"location":"net_ssl-SSLHandshake/#parameters","text":"that: SSLHandshake val","title":"Parameters"},{"location":"net_ssl-SSLHandshake/#returns_1","text":"Bool val","title":"Returns"},{"location":"net_ssl-SSLHandshake/#ne","text":"[Source] fun box ne( that: SSLHandshake val) : Bool val","title":"ne"},{"location":"net_ssl-SSLHandshake/#parameters_1","text":"that: SSLHandshake val","title":"Parameters"},{"location":"net_ssl-SSLHandshake/#returns_2","text":"Bool val","title":"Returns"},{"location":"net_ssl-SSLReady/","text":"SSLReady \u00b6 [Source] primitive val SSLReady Constructors \u00b6 create \u00b6 [Source] new val create() : SSLReady val^ Returns \u00b6 SSLReady val^ Public Functions \u00b6 eq \u00b6 [Source] fun box eq( that: SSLReady val) : Bool val Parameters \u00b6 that: SSLReady val Returns \u00b6 Bool val ne \u00b6 [Source] fun box ne( that: SSLReady val) : Bool val Parameters \u00b6 that: SSLReady val Returns \u00b6 Bool val","title":"primitive SSLReady"},{"location":"net_ssl-SSLReady/#sslready","text":"[Source] primitive val SSLReady","title":"SSLReady"},{"location":"net_ssl-SSLReady/#constructors","text":"","title":"Constructors"},{"location":"net_ssl-SSLReady/#create","text":"[Source] new val create() : SSLReady val^","title":"create"},{"location":"net_ssl-SSLReady/#returns","text":"SSLReady val^","title":"Returns"},{"location":"net_ssl-SSLReady/#public-functions","text":"","title":"Public Functions"},{"location":"net_ssl-SSLReady/#eq","text":"[Source] fun box eq( that: SSLReady val) : Bool val","title":"eq"},{"location":"net_ssl-SSLReady/#parameters","text":"that: SSLReady val","title":"Parameters"},{"location":"net_ssl-SSLReady/#returns_1","text":"Bool val","title":"Returns"},{"location":"net_ssl-SSLReady/#ne","text":"[Source] fun box ne( that: SSLReady val) : Bool val","title":"ne"},{"location":"net_ssl-SSLReady/#parameters_1","text":"that: SSLReady val","title":"Parameters"},{"location":"net_ssl-SSLReady/#returns_2","text":"Bool val","title":"Returns"},{"location":"net_ssl-SSLState/","text":"SSLState \u00b6 [Source] type SSLState is (SSLHandshake val | SSLAuthFail val | SSLReady val | SSLError val) Type Alias For \u00b6 ( SSLHandshake val | SSLAuthFail val | SSLReady val | SSLError val)","title":"type SSLState"},{"location":"net_ssl-SSLState/#sslstate","text":"[Source] type SSLState is (SSLHandshake val | SSLAuthFail val | SSLReady val | SSLError val)","title":"SSLState"},{"location":"net_ssl-SSLState/#type-alias-for","text":"( SSLHandshake val | SSLAuthFail val | SSLReady val | SSLError val)","title":"Type Alias For"},{"location":"net_ssl-Ssl3Version/","text":"Ssl3Version \u00b6 [Source] primitive val Ssl3Version Constructors \u00b6 create \u00b6 [Source] new val create() : Ssl3Version val^ Returns \u00b6 Ssl3Version val^ Public Functions \u00b6 apply \u00b6 [Source] fun val apply() : ULong val Returns \u00b6 ULong val eq \u00b6 [Source] fun box eq( that: Ssl3Version val) : Bool val Parameters \u00b6 that: Ssl3Version val Returns \u00b6 Bool val ne \u00b6 [Source] fun box ne( that: Ssl3Version val) : Bool val Parameters \u00b6 that: Ssl3Version val Returns \u00b6 Bool val","title":"primitive Ssl3Version"},{"location":"net_ssl-Ssl3Version/#ssl3version","text":"[Source] primitive val Ssl3Version","title":"Ssl3Version"},{"location":"net_ssl-Ssl3Version/#constructors","text":"","title":"Constructors"},{"location":"net_ssl-Ssl3Version/#create","text":"[Source] new val create() : Ssl3Version val^","title":"create"},{"location":"net_ssl-Ssl3Version/#returns","text":"Ssl3Version val^","title":"Returns"},{"location":"net_ssl-Ssl3Version/#public-functions","text":"","title":"Public Functions"},{"location":"net_ssl-Ssl3Version/#apply","text":"[Source] fun val apply() : ULong val","title":"apply"},{"location":"net_ssl-Ssl3Version/#returns_1","text":"ULong val","title":"Returns"},{"location":"net_ssl-Ssl3Version/#eq","text":"[Source] fun box eq( that: Ssl3Version val) : Bool val","title":"eq"},{"location":"net_ssl-Ssl3Version/#parameters","text":"that: Ssl3Version val","title":"Parameters"},{"location":"net_ssl-Ssl3Version/#returns_2","text":"Bool val","title":"Returns"},{"location":"net_ssl-Ssl3Version/#ne","text":"[Source] fun box ne( that: Ssl3Version val) : Bool val","title":"ne"},{"location":"net_ssl-Ssl3Version/#parameters_1","text":"that: Ssl3Version val","title":"Parameters"},{"location":"net_ssl-Ssl3Version/#returns_3","text":"Bool val","title":"Returns"},{"location":"net_ssl-SslAutoVersion/","text":"SslAutoVersion \u00b6 [Source] primitive val SslAutoVersion Constructors \u00b6 create \u00b6 [Source] new val create() : SslAutoVersion val^ Returns \u00b6 SslAutoVersion val^ Public Functions \u00b6 apply \u00b6 [Source] fun val apply() : ULong val Returns \u00b6 ULong val eq \u00b6 [Source] fun box eq( that: SslAutoVersion val) : Bool val Parameters \u00b6 that: SslAutoVersion val Returns \u00b6 Bool val ne \u00b6 [Source] fun box ne( that: SslAutoVersion val) : Bool val Parameters \u00b6 that: SslAutoVersion val Returns \u00b6 Bool val","title":"primitive SslAutoVersion"},{"location":"net_ssl-SslAutoVersion/#sslautoversion","text":"[Source] primitive val SslAutoVersion","title":"SslAutoVersion"},{"location":"net_ssl-SslAutoVersion/#constructors","text":"","title":"Constructors"},{"location":"net_ssl-SslAutoVersion/#create","text":"[Source] new val create() : SslAutoVersion val^","title":"create"},{"location":"net_ssl-SslAutoVersion/#returns","text":"SslAutoVersion val^","title":"Returns"},{"location":"net_ssl-SslAutoVersion/#public-functions","text":"","title":"Public Functions"},{"location":"net_ssl-SslAutoVersion/#apply","text":"[Source] fun val apply() : ULong val","title":"apply"},{"location":"net_ssl-SslAutoVersion/#returns_1","text":"ULong val","title":"Returns"},{"location":"net_ssl-SslAutoVersion/#eq","text":"[Source] fun box eq( that: SslAutoVersion val) : Bool val","title":"eq"},{"location":"net_ssl-SslAutoVersion/#parameters","text":"that: SslAutoVersion val","title":"Parameters"},{"location":"net_ssl-SslAutoVersion/#returns_2","text":"Bool val","title":"Returns"},{"location":"net_ssl-SslAutoVersion/#ne","text":"[Source] fun box ne( that: SslAutoVersion val) : Bool val","title":"ne"},{"location":"net_ssl-SslAutoVersion/#parameters_1","text":"that: SslAutoVersion val","title":"Parameters"},{"location":"net_ssl-SslAutoVersion/#returns_3","text":"Bool val","title":"Returns"},{"location":"net_ssl-Tls1Version/","text":"Tls1Version \u00b6 [Source] primitive val Tls1Version Constructors \u00b6 create \u00b6 [Source] new val create() : Tls1Version val^ Returns \u00b6 Tls1Version val^ Public Functions \u00b6 apply \u00b6 [Source] fun val apply() : ULong val Returns \u00b6 ULong val eq \u00b6 [Source] fun box eq( that: Tls1Version val) : Bool val Parameters \u00b6 that: Tls1Version val Returns \u00b6 Bool val ne \u00b6 [Source] fun box ne( that: Tls1Version val) : Bool val Parameters \u00b6 that: Tls1Version val Returns \u00b6 Bool val","title":"primitive Tls1Version"},{"location":"net_ssl-Tls1Version/#tls1version","text":"[Source] primitive val Tls1Version","title":"Tls1Version"},{"location":"net_ssl-Tls1Version/#constructors","text":"","title":"Constructors"},{"location":"net_ssl-Tls1Version/#create","text":"[Source] new val create() : Tls1Version val^","title":"create"},{"location":"net_ssl-Tls1Version/#returns","text":"Tls1Version val^","title":"Returns"},{"location":"net_ssl-Tls1Version/#public-functions","text":"","title":"Public Functions"},{"location":"net_ssl-Tls1Version/#apply","text":"[Source] fun val apply() : ULong val","title":"apply"},{"location":"net_ssl-Tls1Version/#returns_1","text":"ULong val","title":"Returns"},{"location":"net_ssl-Tls1Version/#eq","text":"[Source] fun box eq( that: Tls1Version val) : Bool val","title":"eq"},{"location":"net_ssl-Tls1Version/#parameters","text":"that: Tls1Version val","title":"Parameters"},{"location":"net_ssl-Tls1Version/#returns_2","text":"Bool val","title":"Returns"},{"location":"net_ssl-Tls1Version/#ne","text":"[Source] fun box ne( that: Tls1Version val) : Bool val","title":"ne"},{"location":"net_ssl-Tls1Version/#parameters_1","text":"that: Tls1Version val","title":"Parameters"},{"location":"net_ssl-Tls1Version/#returns_3","text":"Bool val","title":"Returns"},{"location":"net_ssl-Tls1u1Version/","text":"Tls1u1Version \u00b6 [Source] primitive val Tls1u1Version Constructors \u00b6 create \u00b6 [Source] new val create() : Tls1u1Version val^ Returns \u00b6 Tls1u1Version val^ Public Functions \u00b6 apply \u00b6 [Source] fun val apply() : ULong val Returns \u00b6 ULong val eq \u00b6 [Source] fun box eq( that: Tls1u1Version val) : Bool val Parameters \u00b6 that: Tls1u1Version val Returns \u00b6 Bool val ne \u00b6 [Source] fun box ne( that: Tls1u1Version val) : Bool val Parameters \u00b6 that: Tls1u1Version val Returns \u00b6 Bool val","title":"primitive Tls1u1Version"},{"location":"net_ssl-Tls1u1Version/#tls1u1version","text":"[Source] primitive val Tls1u1Version","title":"Tls1u1Version"},{"location":"net_ssl-Tls1u1Version/#constructors","text":"","title":"Constructors"},{"location":"net_ssl-Tls1u1Version/#create","text":"[Source] new val create() : Tls1u1Version val^","title":"create"},{"location":"net_ssl-Tls1u1Version/#returns","text":"Tls1u1Version val^","title":"Returns"},{"location":"net_ssl-Tls1u1Version/#public-functions","text":"","title":"Public Functions"},{"location":"net_ssl-Tls1u1Version/#apply","text":"[Source] fun val apply() : ULong val","title":"apply"},{"location":"net_ssl-Tls1u1Version/#returns_1","text":"ULong val","title":"Returns"},{"location":"net_ssl-Tls1u1Version/#eq","text":"[Source] fun box eq( that: Tls1u1Version val) : Bool val","title":"eq"},{"location":"net_ssl-Tls1u1Version/#parameters","text":"that: Tls1u1Version val","title":"Parameters"},{"location":"net_ssl-Tls1u1Version/#returns_2","text":"Bool val","title":"Returns"},{"location":"net_ssl-Tls1u1Version/#ne","text":"[Source] fun box ne( that: Tls1u1Version val) : Bool val","title":"ne"},{"location":"net_ssl-Tls1u1Version/#parameters_1","text":"that: Tls1u1Version val","title":"Parameters"},{"location":"net_ssl-Tls1u1Version/#returns_3","text":"Bool val","title":"Returns"},{"location":"net_ssl-Tls1u2Version/","text":"Tls1u2Version \u00b6 [Source] primitive val Tls1u2Version Constructors \u00b6 create \u00b6 [Source] new val create() : Tls1u2Version val^ Returns \u00b6 Tls1u2Version val^ Public Functions \u00b6 apply \u00b6 [Source] fun val apply() : ULong val Returns \u00b6 ULong val eq \u00b6 [Source] fun box eq( that: Tls1u2Version val) : Bool val Parameters \u00b6 that: Tls1u2Version val Returns \u00b6 Bool val ne \u00b6 [Source] fun box ne( that: Tls1u2Version val) : Bool val Parameters \u00b6 that: Tls1u2Version val Returns \u00b6 Bool val","title":"primitive Tls1u2Version"},{"location":"net_ssl-Tls1u2Version/#tls1u2version","text":"[Source] primitive val Tls1u2Version","title":"Tls1u2Version"},{"location":"net_ssl-Tls1u2Version/#constructors","text":"","title":"Constructors"},{"location":"net_ssl-Tls1u2Version/#create","text":"[Source] new val create() : Tls1u2Version val^","title":"create"},{"location":"net_ssl-Tls1u2Version/#returns","text":"Tls1u2Version val^","title":"Returns"},{"location":"net_ssl-Tls1u2Version/#public-functions","text":"","title":"Public Functions"},{"location":"net_ssl-Tls1u2Version/#apply","text":"[Source] fun val apply() : ULong val","title":"apply"},{"location":"net_ssl-Tls1u2Version/#returns_1","text":"ULong val","title":"Returns"},{"location":"net_ssl-Tls1u2Version/#eq","text":"[Source] fun box eq( that: Tls1u2Version val) : Bool val","title":"eq"},{"location":"net_ssl-Tls1u2Version/#parameters","text":"that: Tls1u2Version val","title":"Parameters"},{"location":"net_ssl-Tls1u2Version/#returns_2","text":"Bool val","title":"Returns"},{"location":"net_ssl-Tls1u2Version/#ne","text":"[Source] fun box ne( that: Tls1u2Version val) : Bool val","title":"ne"},{"location":"net_ssl-Tls1u2Version/#parameters_1","text":"that: Tls1u2Version val","title":"Parameters"},{"location":"net_ssl-Tls1u2Version/#returns_3","text":"Bool val","title":"Returns"},{"location":"net_ssl-Tls1u3Version/","text":"Tls1u3Version \u00b6 [Source] primitive val Tls1u3Version Constructors \u00b6 create \u00b6 [Source] new val create() : Tls1u3Version val^ Returns \u00b6 Tls1u3Version val^ Public Functions \u00b6 apply \u00b6 [Source] fun val apply() : ULong val Returns \u00b6 ULong val eq \u00b6 [Source] fun box eq( that: Tls1u3Version val) : Bool val Parameters \u00b6 that: Tls1u3Version val Returns \u00b6 Bool val ne \u00b6 [Source] fun box ne( that: Tls1u3Version val) : Bool val Parameters \u00b6 that: Tls1u3Version val Returns \u00b6 Bool val","title":"primitive Tls1u3Version"},{"location":"net_ssl-Tls1u3Version/#tls1u3version","text":"[Source] primitive val Tls1u3Version","title":"Tls1u3Version"},{"location":"net_ssl-Tls1u3Version/#constructors","text":"","title":"Constructors"},{"location":"net_ssl-Tls1u3Version/#create","text":"[Source] new val create() : Tls1u3Version val^","title":"create"},{"location":"net_ssl-Tls1u3Version/#returns","text":"Tls1u3Version val^","title":"Returns"},{"location":"net_ssl-Tls1u3Version/#public-functions","text":"","title":"Public Functions"},{"location":"net_ssl-Tls1u3Version/#apply","text":"[Source] fun val apply() : ULong val","title":"apply"},{"location":"net_ssl-Tls1u3Version/#returns_1","text":"ULong val","title":"Returns"},{"location":"net_ssl-Tls1u3Version/#eq","text":"[Source] fun box eq( that: Tls1u3Version val) : Bool val","title":"eq"},{"location":"net_ssl-Tls1u3Version/#parameters","text":"that: Tls1u3Version val","title":"Parameters"},{"location":"net_ssl-Tls1u3Version/#returns_2","text":"Bool val","title":"Returns"},{"location":"net_ssl-Tls1u3Version/#ne","text":"[Source] fun box ne( that: Tls1u3Version val) : Bool val","title":"ne"},{"location":"net_ssl-Tls1u3Version/#parameters_1","text":"that: Tls1u3Version val","title":"Parameters"},{"location":"net_ssl-Tls1u3Version/#returns_3","text":"Bool val","title":"Returns"},{"location":"net_ssl-TlsMaxVersion/","text":"TlsMaxVersion \u00b6 [Source] primitive val TlsMaxVersion Constructors \u00b6 create \u00b6 [Source] new val create() : TlsMaxVersion val^ Returns \u00b6 TlsMaxVersion val^ Public Functions \u00b6 apply \u00b6 [Source] fun val apply() : ULong val Returns \u00b6 ULong val eq \u00b6 [Source] fun box eq( that: TlsMaxVersion val) : Bool val Parameters \u00b6 that: TlsMaxVersion val Returns \u00b6 Bool val ne \u00b6 [Source] fun box ne( that: TlsMaxVersion val) : Bool val Parameters \u00b6 that: TlsMaxVersion val Returns \u00b6 Bool val","title":"primitive TlsMaxVersion"},{"location":"net_ssl-TlsMaxVersion/#tlsmaxversion","text":"[Source] primitive val TlsMaxVersion","title":"TlsMaxVersion"},{"location":"net_ssl-TlsMaxVersion/#constructors","text":"","title":"Constructors"},{"location":"net_ssl-TlsMaxVersion/#create","text":"[Source] new val create() : TlsMaxVersion val^","title":"create"},{"location":"net_ssl-TlsMaxVersion/#returns","text":"TlsMaxVersion val^","title":"Returns"},{"location":"net_ssl-TlsMaxVersion/#public-functions","text":"","title":"Public Functions"},{"location":"net_ssl-TlsMaxVersion/#apply","text":"[Source] fun val apply() : ULong val","title":"apply"},{"location":"net_ssl-TlsMaxVersion/#returns_1","text":"ULong val","title":"Returns"},{"location":"net_ssl-TlsMaxVersion/#eq","text":"[Source] fun box eq( that: TlsMaxVersion val) : Bool val","title":"eq"},{"location":"net_ssl-TlsMaxVersion/#parameters","text":"that: TlsMaxVersion val","title":"Parameters"},{"location":"net_ssl-TlsMaxVersion/#returns_2","text":"Bool val","title":"Returns"},{"location":"net_ssl-TlsMaxVersion/#ne","text":"[Source] fun box ne( that: TlsMaxVersion val) : Bool val","title":"ne"},{"location":"net_ssl-TlsMaxVersion/#parameters_1","text":"that: TlsMaxVersion val","title":"Parameters"},{"location":"net_ssl-TlsMaxVersion/#returns_3","text":"Bool val","title":"Returns"},{"location":"net_ssl-TlsMinVersion/","text":"TlsMinVersion \u00b6 [Source] primitive val TlsMinVersion Constructors \u00b6 create \u00b6 [Source] new val create() : TlsMinVersion val^ Returns \u00b6 TlsMinVersion val^ Public Functions \u00b6 apply \u00b6 [Source] fun val apply() : ULong val Returns \u00b6 ULong val eq \u00b6 [Source] fun box eq( that: TlsMinVersion val) : Bool val Parameters \u00b6 that: TlsMinVersion val Returns \u00b6 Bool val ne \u00b6 [Source] fun box ne( that: TlsMinVersion val) : Bool val Parameters \u00b6 that: TlsMinVersion val Returns \u00b6 Bool val","title":"primitive TlsMinVersion"},{"location":"net_ssl-TlsMinVersion/#tlsminversion","text":"[Source] primitive val TlsMinVersion","title":"TlsMinVersion"},{"location":"net_ssl-TlsMinVersion/#constructors","text":"","title":"Constructors"},{"location":"net_ssl-TlsMinVersion/#create","text":"[Source] new val create() : TlsMinVersion val^","title":"create"},{"location":"net_ssl-TlsMinVersion/#returns","text":"TlsMinVersion val^","title":"Returns"},{"location":"net_ssl-TlsMinVersion/#public-functions","text":"","title":"Public Functions"},{"location":"net_ssl-TlsMinVersion/#apply","text":"[Source] fun val apply() : ULong val","title":"apply"},{"location":"net_ssl-TlsMinVersion/#returns_1","text":"ULong val","title":"Returns"},{"location":"net_ssl-TlsMinVersion/#eq","text":"[Source] fun box eq( that: TlsMinVersion val) : Bool val","title":"eq"},{"location":"net_ssl-TlsMinVersion/#parameters","text":"that: TlsMinVersion val","title":"Parameters"},{"location":"net_ssl-TlsMinVersion/#returns_2","text":"Bool val","title":"Returns"},{"location":"net_ssl-TlsMinVersion/#ne","text":"[Source] fun box ne( that: TlsMinVersion val) : Bool val","title":"ne"},{"location":"net_ssl-TlsMinVersion/#parameters_1","text":"that: TlsMinVersion val","title":"Parameters"},{"location":"net_ssl-TlsMinVersion/#returns_3","text":"Bool val","title":"Returns"},{"location":"net_ssl-X509/","text":"X509 \u00b6 [Source] primitive val X509 Constructors \u00b6 create \u00b6 [Source] new val create() : X509 val^ Returns \u00b6 X509 val^ Public Functions \u00b6 valid_for_host \u00b6 [Source] Checks if an OpenSSL X509 certificate is valid for a given host. fun box valid_for_host( cert: Pointer[X509 val] ref, host: String val) : Bool val Parameters \u00b6 cert: Pointer [ X509 val] ref host: String val Returns \u00b6 Bool val common_name \u00b6 [Source] Get the common name for the certificate. Raises an error if the common name contains any NULL bytes. fun box common_name( cert: Pointer[X509 val] ref) : String val ? Parameters \u00b6 cert: Pointer [ X509 val] ref Returns \u00b6 String val ? all_names \u00b6 [Source] Returns an array of all names for the certificate. Any names containing NULL bytes are not included. This includes the common name and all subject alternate names. fun box all_names( cert: Pointer[X509 val] ref) : Array[String val] val Parameters \u00b6 cert: Pointer [ X509 val] ref Returns \u00b6 Array [ String val] val eq \u00b6 [Source] fun box eq( that: X509 val) : Bool val Parameters \u00b6 that: X509 val Returns \u00b6 Bool val ne \u00b6 [Source] fun box ne( that: X509 val) : Bool val Parameters \u00b6 that: X509 val Returns \u00b6 Bool val","title":"primitive X509"},{"location":"net_ssl-X509/#x509","text":"[Source] primitive val X509","title":"X509"},{"location":"net_ssl-X509/#constructors","text":"","title":"Constructors"},{"location":"net_ssl-X509/#create","text":"[Source] new val create() : X509 val^","title":"create"},{"location":"net_ssl-X509/#returns","text":"X509 val^","title":"Returns"},{"location":"net_ssl-X509/#public-functions","text":"","title":"Public Functions"},{"location":"net_ssl-X509/#valid_for_host","text":"[Source] Checks if an OpenSSL X509 certificate is valid for a given host. fun box valid_for_host( cert: Pointer[X509 val] ref, host: String val) : Bool val","title":"valid_for_host"},{"location":"net_ssl-X509/#parameters","text":"cert: Pointer [ X509 val] ref host: String val","title":"Parameters"},{"location":"net_ssl-X509/#returns_1","text":"Bool val","title":"Returns"},{"location":"net_ssl-X509/#common_name","text":"[Source] Get the common name for the certificate. Raises an error if the common name contains any NULL bytes. fun box common_name( cert: Pointer[X509 val] ref) : String val ?","title":"common_name"},{"location":"net_ssl-X509/#parameters_1","text":"cert: Pointer [ X509 val] ref","title":"Parameters"},{"location":"net_ssl-X509/#returns_2","text":"String val ?","title":"Returns"},{"location":"net_ssl-X509/#all_names","text":"[Source] Returns an array of all names for the certificate. Any names containing NULL bytes are not included. This includes the common name and all subject alternate names. fun box all_names( cert: Pointer[X509 val] ref) : Array[String val] val","title":"all_names"},{"location":"net_ssl-X509/#parameters_2","text":"cert: Pointer [ X509 val] ref","title":"Parameters"},{"location":"net_ssl-X509/#returns_3","text":"Array [ String val] val","title":"Returns"},{"location":"net_ssl-X509/#eq","text":"[Source] fun box eq( that: X509 val) : Bool val","title":"eq"},{"location":"net_ssl-X509/#parameters_3","text":"that: X509 val","title":"Parameters"},{"location":"net_ssl-X509/#returns_4","text":"Bool val","title":"Returns"},{"location":"net_ssl-X509/#ne","text":"[Source] fun box ne( that: X509 val) : Bool val","title":"ne"},{"location":"net_ssl-X509/#parameters_4","text":"that: X509 val","title":"Parameters"},{"location":"net_ssl-X509/#returns_5","text":"Bool val","title":"Returns"},{"location":"src/net_ssl/alpn/","text":"use \"net\" interface ALPNProtocolNotify fun ref alpn_negotiated(conn: TCPConnection, protocol: (String | None)): None type ALPNProtocolName is String val primitive ALPNFatal primitive ALPNNoAck primitive ALPNWarning type ALPNMatchResult is (ALPNProtocolName | ALPNNoAck | ALPNWarning | ALPNFatal) type _ALPNSelectCallback is @{( Pointer[_SSL] tag, Pointer[Pointer[U8] tag] tag, Pointer[U8] tag, Pointer[U8] box, U32, ALPNProtocolResolver box) : I32} interface box ALPNProtocolResolver \"\"\" Controls the protocol name to be chosen for incomming SSLConnections using the ALPN extension. \"\"\" fun box resolve(advertised: Array[ALPNProtocolName] val): ALPNMatchResult class val ALPNStandardProtocolResolver is ALPNProtocolResolver \"\"\" Implements the standard protocol selection akin to the OpenSSL function `SSL_select_next_proto`. \"\"\" let supported: Array[ALPNProtocolName] val let use_client_as_fallback: Bool new val create( supported': Array[ALPNProtocolName] val, use_client_as_fallback': Bool = true) => supported = supported' use_client_as_fallback = use_client_as_fallback' fun box resolve(advertised: Array[ALPNProtocolName] val): ALPNMatchResult => for sup_proto in supported.values() do for adv_proto in advertised.values() do if sup_proto == adv_proto then return sup_proto end end end if use_client_as_fallback then try return advertised(0)? end end ALPNWarning primitive _ALPNMatchResultCode fun ok(): I32 => 0 fun warning(): I32 => 1 fun fatal(): I32 => 2 fun no_ack(): I32 => 3 primitive _ALPNProtocolList fun from_array(protocols: Array[String] box): String ? => \"\"\" Try to pack the protocol names in `protocols` into a *protocol name list* \"\"\" if protocols.size() == 0 then error end let list = recover trn String end for proto in protocols.values() do let len = proto.size() if (len == 0) or (len > 255) then error end list.push(U8.from[USize](len)) list.append(proto) end list fun to_array(protocol_list: String box): Array[ALPNProtocolName] val ? => \"\"\" Try to unpack a *protocol name list* into an `Array[String]` \"\"\" let arr = recover trn Array[ALPNProtocolName] end var index = USize(1) var remain = try protocol_list(0)? else error end var buf = recover trn String end if remain == 0 then error end while index < protocol_list.size() do let ch = try protocol_list(index)? else error end if remain > 0 then buf.push(ch) remain = remain - 1 end if remain == 0 then let final_protocol: String = buf = recover String end arr.push(final_protocol) let hasNextChar = index < (protocol_list.size() - 1) if hasNextChar then remain = try protocol_list(index + 1)? else error end if remain == 0 then error end index = index + 1 end end index = index + 1 end if remain > 0 then error end arr","title":"Alpn"},{"location":"src/net_ssl/ssl/","text":"use \"net\" use @SSL_ctrl[ILong]( ssl: Pointer[_SSL], op: I32, arg: ILong, parg: Pointer[None]) use @SSL_new[Pointer[_SSL]](ctx: Pointer[_SSLContext] tag) use @SSL_free[None](ssl: Pointer[_SSL] tag) use @SSL_set_verify[None](ssl: Pointer[_SSL], mode: I32, cb: Pointer[U8]) use @BIO_s_mem[Pointer[U8]]() use @BIO_new[Pointer[_BIO]](typ: Pointer[U8]) use @SSL_set_bio[None](ssl: Pointer[_SSL], rbio: Pointer[_BIO] tag, wbio: Pointer[_BIO] tag) use @SSL_set_accept_state[None](ssl: Pointer[_SSL]) use @SSL_set_connect_state[None](ssl: Pointer[_SSL]) use @SSL_do_handshake[I32](ssl: Pointer[_SSL]) use @SSL_get0_alpn_selected[None](ssl: Pointer[_SSL] tag, data: Pointer[Pointer[U8] iso], len: Pointer[U32]) if \"openssl_1.1.x\" use @SSL_pending[I32](ssl: Pointer[_SSL]) use @SSL_read[I32](ssl: Pointer[_SSL], buf: Pointer[U8] tag, len: U32) use @SSL_write[I32](ssl: Pointer[_SSL], buf: Pointer[U8] tag, len: U32) use @BIO_read[I32](bio: Pointer[_BIO] tag, buf: Pointer[U8] tag, len: U32) use @BIO_write[I32](bio: Pointer[_BIO] tag, buf: Pointer[U8] tag, len: U32) use @SSL_get_error[I32](ssl: Pointer[_SSL], ret: I32) use @BIO_ctrl_pending[USize](bio: Pointer[_BIO] tag) use @SSL_has_pending[I32](ssl: Pointer[_SSL]) if \"openssl_1.1.x\" use @SSL_get_peer_certificate[Pointer[X509]](ssl: Pointer[_SSL]) primitive _SSL primitive _BIO primitive SSLHandshake primitive SSLAuthFail primitive SSLReady primitive SSLError type SSLState is (SSLHandshake | SSLAuthFail | SSLReady | SSLError) class SSL \"\"\" An SSL session manages handshakes, encryption and decryption. It is not tied to any transport layer. \"\"\" let _hostname: String var _ssl: Pointer[_SSL] var _input: Pointer[_BIO] tag var _output: Pointer[_BIO] tag var _state: SSLState = SSLHandshake var _read_buf: Array[U8] iso = [] new _create( ctx: Pointer[_SSLContext] tag, server: Bool, verify: Bool, hostname: String = \"\") ? => \"\"\" Create a client or server SSL session from a context. \"\"\" if ctx.is_null() then error end _hostname = hostname _ssl = @SSL_new(ctx) if _ssl.is_null() then error end let mode = if verify then I32(3) else I32(0) end @SSL_set_verify(_ssl, mode, Pointer[U8]) _input = @BIO_new(@BIO_s_mem()) if _input.is_null() then error end _output = @BIO_new(@BIO_s_mem()) if _output.is_null() then error end @SSL_set_bio(_ssl, _input, _output) if (_hostname.size() > 0) and not DNS.is_ip4(_hostname) and not DNS.is_ip6(_hostname) then // SSL_set_tlsext_host_name @SSL_ctrl(_ssl, 55, 0, _hostname.cstring()) end if server then @SSL_set_accept_state(_ssl) else @SSL_set_connect_state(_ssl) @SSL_do_handshake(_ssl) end fun box alpn_selected(): (ALPNProtocolName | None) => \"\"\" Get the protocol identifier negotiated via ALPN \"\"\" var ptr: Pointer[U8] iso = recover Pointer[U8] end var len = U32(0) ifdef \"openssl_1.1.x\" then @SSL_get0_alpn_selected(_ssl, addressof ptr, addressof len) end if ptr.is_null() then None else recover val String.copy_cpointer(consume ptr, USize.from[U32](len)) end end fun state(): SSLState => \"\"\" Returns the SSL session state. \"\"\" _state fun ref read(expect: USize = 0): (Array[U8] iso^ | None) => \"\"\" Returns unencrypted bytes to be passed to the application. If `expect` is non-zero, the number of bytes returned will be exactly `expect`. If no data (or less than `expect` bytes) is available, this returns None. \"\"\" let offset = _read_buf.size() var len = if expect > 0 then if offset >= expect then return _read_buf = [] end expect - offset else 1024 end let max = if expect > 0 then expect - offset else USize.max_value() end let pending = @SSL_pending(_ssl).usize() if pending > 0 then if expect > 0 then len = len.min(pending) else len = pending end _read_buf.undefined(offset + len) @SSL_read(_ssl, _read_buf.cpointer(offset), len.u32()) else _read_buf.undefined(offset + len) let r = @SSL_read(_ssl, _read_buf.cpointer(offset), len.u32()) if r <= 0 then match @SSL_get_error(_ssl, r) | 1 | 5 | 6 => _state = SSLError | 2 => // SSL buffer has more data but it is not yet decoded (or something) _read_buf.truncate(offset) return None end _read_buf.truncate(offset) else _read_buf.truncate(offset + r.usize()) end end let ready = if expect == 0 then _read_buf.size() > 0 else _read_buf.size() == expect end if ready then _read_buf = [] else // try and read again any pending data that SSL hasn't decoded yet if @BIO_ctrl_pending(_input) > 0 then read(expect) else ifdef \"openssl_1.1.x\" then // try and read again any data already decoded from SSL that hasn't // been read via `SSL_has_pending` that was added in 1.1 // This mailing list post has a good description of what it is for: // https://mta.openssl.org/pipermail/openssl-users/2017-January/005110.html if @SSL_has_pending(_ssl) == 1 then read(expect) end end end end fun ref write(data: ByteSeq) ? => \"\"\" When application data is sent, add it to the SSL session. Raises an error if the handshake is not complete. \"\"\" if _state isnt SSLReady then error end if data.size() > 0 then @SSL_write(_ssl, data.cpointer(), data.size().u32()) end fun ref receive(data: ByteSeq) => \"\"\" When data is received, add it to the SSL session. \"\"\" @BIO_write(_input, data.cpointer(), data.size().u32()) if _state is SSLHandshake then let r = @SSL_do_handshake(_ssl) if r > 0 then _verify_hostname() else match @SSL_get_error(_ssl, r) | 1 => _state = SSLAuthFail | 5 | 6 => _state = SSLError end end end fun ref can_send(): Bool => \"\"\" Returns true if there are encrypted bytes to be passed to the destination. \"\"\" @BIO_ctrl_pending(_output) > 0 fun ref send(): Array[U8] iso^ ? => \"\"\" Returns encrypted bytes to be passed to the destination. Raises an error if no data is available. \"\"\" let len = @BIO_ctrl_pending(_output) if len == 0 then error end let buf = recover Array[U8] .> undefined(len) end @BIO_read(_output, buf.cpointer(), buf.size().u32()) buf fun ref dispose() => \"\"\" Dispose of the session. \"\"\" if not _ssl.is_null() then @SSL_free(_ssl) _ssl = Pointer[_SSL] end fun _final() => \"\"\" Dispose of the session. \"\"\" if not _ssl.is_null() then @SSL_free(_ssl) end fun ref _verify_hostname() => \"\"\" Verify that the certificate is valid for the given hostname. \"\"\" if _hostname.size() > 0 then let cert = @SSL_get_peer_certificate(_ssl) let ok = X509.valid_for_host(cert, _hostname) if not cert.is_null() then @X509_free(cert) end if not ok then _state = SSLAuthFail return end end _state = SSLReady","title":"Ssl"},{"location":"src/net_ssl/ssl_connection/","text":"use \"collections\" use \"net\" class SSLConnection is TCPConnectionNotify \"\"\" Wrap another protocol in an SSL connection. \"\"\" let _notify: TCPConnectionNotify let _ssl: SSL var _connected: Bool = false var _expect: USize = 0 var _closed: Bool = false let _pending: List[ByteSeq] = _pending.create() var _accept_pending: Bool = false new iso create(notify: TCPConnectionNotify iso, ssl: SSL iso) => \"\"\" Initialise with a wrapped protocol and an SSL session. \"\"\" _notify = consume notify _ssl = consume ssl fun ref accepted(conn: TCPConnection ref) => \"\"\" Swallow this event until the handshake is complete. \"\"\" _accept_pending = true _poll(conn) fun ref connecting(conn: TCPConnection ref, count: U32) => \"\"\" Forward to the wrapped protocol. \"\"\" _notify.connecting(conn, count) fun ref connected(conn: TCPConnection ref) => \"\"\" Swallow this event until the handshake is complete. \"\"\" _poll(conn) fun ref connect_failed(conn: TCPConnection ref) => \"\"\" Forward to the wrapped protocol. \"\"\" _notify.connect_failed(conn) fun ref sent(conn: TCPConnection ref, data: ByteSeq): ByteSeq => \"\"\" Pass the data to the SSL session and check for both new application data and new destination data. \"\"\" let notified = _notify.sent(conn, data) if _connected then try _ssl.write(notified)? else return \"\" end else _pending.push(notified) end _poll(conn) \"\" fun ref sentv(conn: TCPConnection ref, data: ByteSeqIter): ByteSeqIter => let ret = recover val Array[ByteSeq] end let data' = _notify.sentv(conn, data) for bytes in data'.values() do if _connected then try _ssl.write(bytes)? else return ret end else _pending.push(bytes) end end _poll(conn) ret fun ref received( conn: TCPConnection ref, data: Array[U8] iso, times: USize) : Bool => \"\"\" Pass the data to the SSL session and check for both new application data and new destination data. \"\"\" _ssl.receive(consume data) _poll(conn) true fun ref expect(conn: TCPConnection ref, qty: USize): USize => \"\"\" Keep track of the expect count for the wrapped protocol. Always tell the TCPConnection to read all available data. \"\"\" _expect = _notify.expect(conn, qty) 0 fun ref closed(conn: TCPConnection ref) => \"\"\" Forward to the wrapped protocol. \"\"\" _closed = true _poll(conn) _ssl.dispose() _connected = false _pending.clear() _notify.closed(conn) fun ref throttled(conn: TCPConnection ref) => \"\"\" Forward to the wrapped protocol. \"\"\" _notify.throttled(conn) fun ref unthrottled(conn: TCPConnection ref) => \"\"\" Forward to the wrapped protocol. \"\"\" _notify.unthrottled(conn) fun ref _poll(conn: TCPConnection ref) => \"\"\" Checks for both new application data and new destination data. Informs the wrapped protocol that is has connected when the handshake is complete. \"\"\" match _ssl.state() | SSLReady => if not _connected then _connected = true if _accept_pending then _notify.accepted(conn) else _notify.connected(conn) end match _notify | let alpn_notify: ALPNProtocolNotify => alpn_notify.alpn_negotiated(conn, _ssl.alpn_selected()) end try while _pending.size() > 0 do _ssl.write(_pending.shift()?)? end end end | SSLAuthFail => _notify.auth_failed(conn) if not _closed then conn.close() end return | SSLError => if not _closed then conn.close() end return end try var received_called: USize = 0 while true do let r = _ssl.read(_expect) if r isnt None then received_called = received_called + 1 _notify.received( conn, (consume r) as Array[U8] iso^, received_called) else break end end end try while _ssl.can_send() do conn.write_final(_ssl.send()?) end end","title":"Ssl connection"},{"location":"src/net_ssl/ssl_context/","text":"use \"files\" use \"lib:crypt32\" if windows use \"lib:cryptui\" if windows use @memcpy[Pointer[U8]](dst: Pointer[None], src: Pointer[None], n: USize) use @SSL_CTX_ctrl[ILong]( ctx: Pointer[_SSLContext] tag, op: I32, arg: ULong, parg: Pointer[None]) use @SSLv23_method[Pointer[None]]() if \"openssl_0.9.0\" use @TLS_method[Pointer[None]]() if \"openssl_1.1.x\" use @SSL_CTX_new[Pointer[_SSLContext]](method: Pointer[None]) use @SSL_CTX_free[None](ctx: Pointer[_SSLContext] tag) use @SSL_CTX_clear_options[ULong](ctx: Pointer[_SSLContext] tag, opts: ULong) if \"openssl_1.1.x\" use @SSL_CTX_set_options[ULong](ctx: Pointer[_SSLContext] tag, opts: ULong) if \"openssl_1.1.x\" use @SSL_CTX_use_certificate_chain_file[I32](ctx: Pointer[_SSLContext] tag, file: Pointer[U8] tag) use @SSL_CTX_use_PrivateKey_file[I32](ctx: Pointer[_SSLContext] tag, file: Pointer[U8] tag, typ: I32) use @SSL_CTX_check_private_key[I32](ctx: Pointer[_SSLContext] tag) use @SSL_CTX_load_verify_locations[I32](ctx: Pointer[_SSLContext] tag, ca_file: Pointer[U8] tag, ca_path: Pointer[U8] tag) use @X509_STORE_new[Pointer[U8] tag]() use @CertOpenSystemStoreA[Pointer[U8] tag](prov: Pointer[U8] tag, protcol: Pointer[U8] tag) if windows use @CertEnumCertificatesInStore[NullablePointer[_CertContext]](cert_store: Pointer[U8] tag, prev_ctx: NullablePointer[_CertContext]) if windows use @d2i_X509[Pointer[X509] tag](val_out: Pointer[U8] tag, der_in: Pointer[Pointer[U8]], length: U32) use @X509_STORE_add_cert[U32](store: Pointer[U8] tag, x509: Pointer[X509] tag) use @X509_free[None](x509: Pointer[X509] tag) use @SSL_CTX_set_cert_store[None](ctx: Pointer[_SSLContext] tag, store: Pointer[U8] tag) use @X509_STORE_free[None](store: Pointer[U8] tag) use @CertCloseStore[Bool](store: Pointer[U8] tag, flags: U32) if windows use @SSL_CTX_set_cipher_list[I32](ctx: Pointer[_SSLContext] tag, control: Pointer[U8] tag) use @SSL_CTX_set_verify_depth[None](ctx: Pointer[_SSLContext] tag, depth: U32) use @SSL_CTX_set_alpn_select_cb[None](ctx: Pointer[_SSLContext] tag, cb: _ALPNSelectCallback, resolver: ALPNProtocolResolver) if \"openssl_1.1.x\" use @SSL_CTX_set_alpn_protos[I32](ctx: Pointer[_SSLContext] tag, protos: Pointer[U8] tag, protos_len: USize) if \"openssl_1.1.x\" primitive _SSLContext primitive _SslCtrlSetOptions fun val apply(): I32 => 32 primitive _SslCtrlClearOptions fun val apply(): I32 => 77 // These are the SSL_OP_NO_{SSL|TLS}vx{_x} in ssl.h. // Since Pony doesn't allow underscore we use camel case // and began them with underscore to keep them private. // Also, in the version strings the \"v\" becomes \"V\" and // the underscore \"_\" becomes \"u\". So SSL_OP_NO_TLSv1_2 // _SslOpNo_TlsV1u2. primitive _SslOpNoSslV2 fun val apply(): ULong => 0x01000000 // 0 in 1.1 primitive _SslOpNoSslV3 fun val apply(): ULong => 0x02000000 primitive _SslOpNoTlsV1 fun val apply(): ULong => 0x04000000 primitive _SslOpNoTlsV1u2 fun val apply(): ULong => 0x08000000 primitive _SslOpNoTlsV1u1 fun val apply(): ULong => 0x10000000 primitive _SslOpNoTlsV1u3 fun val apply(): ULong => 0x20000000 primitive _SslOpNoDtlsV1 fun val apply(): ULong => 0x04000000 primitive _SslOpNoDtlsV1u2 fun val apply(): ULong => 0x08000000 // Defined as SSL_OP_NO_SSL_MASK in ssl.h primitive _SslOpNoSslMask fun val apply(): ULong => _SslOpNoSslV3() + _SslOpNoTlsV1() + _SslOpNoTlsV1u1() + _SslOpNoTlsV1u2() + _SslOpNoTlsV1u3() // Defined as SSL_OP_NO_DTLS_MASK in ssl.h primitive _SslOpNoDtlsMask fun val apply(): ULong => _SslOpNoDtlsV1() + _SslOpNoDtlsV1u2() class val SSLContext \"\"\" An SSL context is used to create SSL sessions. \"\"\" var _ctx: Pointer[_SSLContext] tag var _client_verify: Bool = true var _server_verify: Bool = false new create() => \"\"\" Create an SSL context. \"\"\" ifdef \"openssl_1.1.x\" then _ctx = @SSL_CTX_new(@TLS_method()) // Allow only newer ciphers. try set_min_proto_version(Tls1u2Version())? set_max_proto_version(SslAutoVersion())? end elseif \"openssl_0.9.0\" then _ctx = @SSL_CTX_new(@SSLv23_method()) // Disable \"all\" SSL/TSL options _set_options(_SslOpNoSslMask() + _SslOpNoSslV2()) // Allow only newer ciphers allow_tls_v1_2(true) else compile_error \"You must select an SSL version to use.\" end fun _set_options(opts: ULong) => ifdef \"openssl_1.1.x\" then @SSL_CTX_set_options(_ctx, opts) elseif \"openssl_0.9.0\" then @SSL_CTX_ctrl(_ctx, _SslCtrlSetOptions(), opts, Pointer[None]) else compile_error \"You must select an SSL version to use.\" end fun _clear_options(opts: ULong) => ifdef \"openssl_1.1.x\" then @SSL_CTX_clear_options(_ctx, opts) elseif \"openssl_0.9.0\" then @SSL_CTX_ctrl(_ctx, _SslCtrlClearOptions(), opts, Pointer[None]) else compile_error \"You must select an SSL version to use.\" end fun client(hostname: String = \"\"): SSL iso^ ? => \"\"\" Create a client-side SSL session. If a hostname is supplied, the server side certificate must be valid for that hostname. \"\"\" let ctx = _ctx let verify = _client_verify recover SSL._create(ctx, false, verify, hostname)? end fun server(): SSL iso^ ? => \"\"\" Create a server-side SSL session. \"\"\" let ctx = _ctx let verify = _server_verify recover SSL._create(ctx, true, verify)? end fun ref set_cert(cert: FilePath, key: FilePath) ? => \"\"\" The cert file is a PEM certificate chain. The key file is a private key. Servers must set this. For clients, it is optional. \"\"\" if _ctx.is_null() or (cert.path.size() == 0) or (key.path.size() == 0) or (0 == @SSL_CTX_use_certificate_chain_file( _ctx, cert.path.cstring())) or (0 == @SSL_CTX_use_PrivateKey_file( _ctx, key.path.cstring(), I32(1))) or (0 == @SSL_CTX_check_private_key(_ctx)) then error end fun ref set_authority( file: (FilePath | None), path: (FilePath | None) = None) ? => \"\"\" Use a PEM file and/or a directory of PEM files to specify certificate authorities. Clients must set this. For servers, it is optional. Use None to indicate no file or no path. Raises an error if these verify locations aren't valid. If both `file` and `path` are `None`, on Windows this method loads the system root certificates. On Posix it raises an error. \"\"\" if (file is None) and (path is None) then ifdef windows then _load_windows_root_certs()? else error end else let fs = try (file as FilePath).path else \"\" end let ps = try (path as FilePath).path else \"\" end let f = if fs.size() > 0 then fs.cstring() else Pointer[U8] end let p = if ps.size() > 0 then ps.cstring() else Pointer[U8] end if _ctx.is_null() or (f.is_null() and p.is_null()) or (0 == @SSL_CTX_load_verify_locations(_ctx, f, p)) then error end end fun ref _load_windows_root_certs() ? => ifdef windows then let root_str = \"ROOT\" let hStore = @CertOpenSystemStoreA(Pointer[U8], root_str.cstring()) if hStore.is_null() then error end let x509_store = @X509_STORE_new() if x509_store.is_null() then error end try var pContext: NullablePointer[_CertContext] pContext = @CertEnumCertificatesInStore(hStore, NullablePointer[_CertContext].none()) while not pContext.is_none() do let cert_context = pContext()? let x509 = @d2i_X509(Pointer[U8], addressof cert_context.pbCertEncoded, cert_context.cbCertEncoded) if not x509.is_null() then let result = @X509_STORE_add_cert(x509_store, x509) @X509_free(x509) if result != 1 then error end end pContext = @CertEnumCertificatesInStore(hStore, pContext) end @SSL_CTX_set_cert_store(_ctx, x509_store) else @X509_STORE_free(x509_store) then @CertCloseStore(hStore, U32(0)) end end fun ref set_ciphers(ciphers: String) ? => \"\"\" Set the accepted ciphers. This replaces the existing list. Raises an error if the cipher list is invalid. \"\"\" if _ctx.is_null() or (0 == @SSL_CTX_set_cipher_list(_ctx, ciphers.cstring())) then error end fun ref set_client_verify(state: Bool) => \"\"\" Set to true to require verification. Defaults to true. \"\"\" _client_verify = state fun ref set_server_verify(state: Bool) => \"\"\" Set to true to require verification. Defaults to false. \"\"\" _server_verify = state fun ref set_verify_depth(depth: U32) => \"\"\" Set the verify depth. Defaults to 6. \"\"\" if not _ctx.is_null() then @SSL_CTX_set_verify_depth(_ctx, depth) end fun ref set_min_proto_version(version: ULong) ? => \"\"\" Set minimum protocol version. Set to SslAutoVersion, 0, to automatically manage lowest version. Supported versions: Ssl3Version, Tls1Version, Tls1u1Version, Tls1u2Version, Tls1u3Version, Dtls1Version, Dtls1u2Version \"\"\" let result = @SSL_CTX_ctrl(_ctx, _SslCtrlSetMinProtoVersion(), version, Pointer[None]) if result == 0 then error end fun ref get_min_proto_version(): ILong => \"\"\" Get minimum protocol version. Returns SslAutoVersion, 0, when automatically managing lowest version. Supported versions: Ssl3Version, Tls1Version, Tls1u1Version, Tls1u2Version, Tls1u3Version, Dtls1Version, Dtls1u2Version \"\"\" @SSL_CTX_ctrl(_ctx, _SslCtrlGetMinProtoVersion(), 0, Pointer[None]) fun ref set_max_proto_version(version: ULong) ? => \"\"\" Set maximum protocol version. Set to SslAutoVersion, 0, to automatically manage higest version. Supported versions: Ssl3Version, Tls1Version, Tls1u1Version, Tls1u2Version, Tls1u3Version, Dtls1Version, Dtls1u2Version \"\"\" let result = @SSL_CTX_ctrl(_ctx, _SslCtrlSetMaxProtoVersion(), version, Pointer[None]) if result == 0 then error end fun ref get_max_proto_version(): ILong => \"\"\" Get maximum protocol version. Returns SslAutoVersion, 0, when automatically managing highest version. Supported versions: Ssl3Version, Tls1Version, Tls1u1Version, Tls1u2Version, Tls1u3Version, Dtls1Version, Dtls1u2Version \"\"\" @SSL_CTX_ctrl(_ctx, _SslCtrlGetMaxProtoVersion(), 0, Pointer[None]) fun ref alpn_set_resolver(resolver: ALPNProtocolResolver box): Bool => \"\"\" Use `resolver` to choose the protocol to be selected for incomming connections. Returns true on success Requires OpenSSL >= 1.0.2 \"\"\" ifdef \"openssl_1.1.x\" then @SSL_CTX_set_alpn_select_cb( _ctx, addressof SSLContext._alpn_select_cb, resolver) return true elseif \"openssl_0.9.0\" then return false else compile_error \"You must select an SSL version to use.\" end fun ref alpn_set_client_protocols(protocols: Array[String] box): Bool => \"\"\" Configures the SSLContext to advertise the protocol names defined in `protocols` when connecting to a server protocol names must have a size of 1 to 255 Returns true on success Requires OpenSSL >= 1.0.2 \"\"\" ifdef \"openssl_1.1.x\" then try let proto_list = _ALPNProtocolList.from_array(protocols)? let result = @SSL_CTX_set_alpn_protos( _ctx, proto_list.cpointer(), proto_list.size()) return result == 0 end elseif \"openssl_0.9.0\" then return false else compile_error \"You must select an SSL version to use.\" end false fun @_alpn_select_cb( ssl: Pointer[_SSL] tag, out: Pointer[Pointer[U8] tag] tag, outlen: Pointer[U8] tag, inptr: Pointer[U8] box, inlen: U32, resolver: ALPNProtocolResolver box) : I32 => let proto_arr_str = String.copy_cpointer(inptr, USize.from[U32](inlen)) try let proto_arr = _ALPNProtocolList.to_array(proto_arr_str)? match resolver.resolve(proto_arr) | let matched: String => var size = matched.size() if (size > 0) and (size <= 255) then var ptr = matched.cpointer() @memcpy(out, addressof ptr, size.bitwidth() / 8) @memcpy(outlen, addressof size, USize(1)) _ALPNMatchResultCode.ok() else _ALPNMatchResultCode.fatal() end | ALPNNoAck => _ALPNMatchResultCode.no_ack() | ALPNWarning => _ALPNMatchResultCode.warning() | ALPNFatal => _ALPNMatchResultCode.fatal() end else _ALPNMatchResultCode.fatal() end fun ref allow_tls_v1(state: Bool) => \"\"\" Allow TLS v1. Defaults to false. Deprecated: use set_min_proto_version and set_max_proto_version \"\"\" if not _ctx.is_null() then if state then _clear_options(_SslOpNoTlsV1()) else _set_options(_SslOpNoTlsV1()) end end fun ref allow_tls_v1_1(state: Bool) => \"\"\" Allow TLS v1.1. Defaults to false. Deprecated: use set_min_proto_version and set_max_proto_version \"\"\" if not _ctx.is_null() then if state then _clear_options(_SslOpNoTlsV1u1()) else _set_options(_SslOpNoTlsV1u1()) end end fun ref allow_tls_v1_2(state: Bool) => \"\"\" Allow TLS v1.2. Defaults to true. Deprecated: use set_min_proto_version and set_max_proto_version \"\"\" if not _ctx.is_null() then if state then _clear_options(_SslOpNoTlsV1u2()) else _set_options(_SslOpNoTlsV1u2()) end end fun ref dispose() => \"\"\" Free the SSL context. \"\"\" if not _ctx.is_null() then @SSL_CTX_free(_ctx) _ctx = Pointer[_SSLContext] end fun _final() => \"\"\" Free the SSL context. \"\"\" if not _ctx.is_null() then @SSL_CTX_free(_ctx) end struct _CertContext var dwCertEncodingType: U32 = 0 var pbCertEncoded: Pointer[U8] = Pointer[U8] var cbCertEncoded: U32 = 0","title":"Ssl context"},{"location":"src/net_ssl/ssl_versions/","text":"primitive SslAutoVersion fun val apply(): ULong => 0x0 primitive Ssl3Version fun val apply(): ULong => 0x300 primitive Tls1Version fun val apply(): ULong => 0x301 primitive Tls1u1Version fun val apply(): ULong => 0x302 primitive Tls1u2Version fun val apply(): ULong => 0x303 primitive Tls1u3Version fun val apply(): ULong => 0x304 primitive Dtls1Version fun val apply(): ULong => 0xFEFF primitive Dtls1u2Version fun val apply(): ULong => 0xFEFD primitive TlsMinVersion fun val apply(): ULong => Tls1Version() primitive TlsMaxVersion fun val apply(): ULong => Tls1u3Version() primitive DtlsMinVersion fun val apply(): ULong => Dtls1Version() primitive DtlsMaxVersion fun val apply(): ULong => Dtls1u2Version()","title":"Ssl versions"},{"location":"src/net_ssl/x509/","text":"use \"collections\" use \"net\" use @pony_os_ip_string[Pointer[U8]](src: Pointer[U8], len: I32) use @X509_get_subject_name[Pointer[_X509Name]](cert: Pointer[X509]) use @X509_NAME_get_text_by_NID[I32](name: Pointer[_X509Name], nid: I32, buf: Pointer[U8] tag, len: I32) use @X509_get_ext_d2i[Pointer[_GeneralNameStack]](cert: Pointer[X509], nid: I32, crit: Pointer[U8], idx: Pointer[U8]) use @OPENSSL_sk_pop[Pointer[_GeneralName]](stack: Pointer[_GeneralNameStack]) if \"openssl_1.1.x\" use @sk_pop[Pointer[_GeneralName]](stack: Pointer[_GeneralNameStack]) if \"openssl_0.9.0\" use @GENERAL_NAME_get0_value[Pointer[U8] tag](name: Pointer[_GeneralName], ptype: Pointer[I32]) use @ASN1_STRING_type[I32](value: Pointer[U8] tag) use @ASN1_STRING_get0_data[Pointer[U8]](value: Pointer[U8] tag) use @ASN1_STRING_length[I32](value: Pointer[U8] tag) use @GENERAL_NAME_free[None](name: Pointer[_GeneralName]) use @OPENSSL_sk_free[None](stack: Pointer[_GeneralNameStack]) if \"openssl_1.1.x\" use @sk_free[None](stack: Pointer[_GeneralNameStack]) if \"openssl_0.9.0\" primitive _X509Name primitive _GeneralName primitive _GeneralNameStack primitive X509 fun valid_for_host(cert: Pointer[X509], host: String): Bool => \"\"\" Checks if an OpenSSL X509 certificate is valid for a given host. \"\"\" for name in all_names(cert).values() do if _match_name(host, name) then return true end end false fun common_name(cert: Pointer[X509]): String ? => \"\"\" Get the common name for the certificate. Raises an error if the common name contains any NULL bytes. \"\"\" if cert.is_null() then error end let subject = @X509_get_subject_name(cert) let len = @X509_NAME_get_text_by_NID(subject, I32(13), Pointer[U8], I32(0)) if len < 0 then error end let common = recover String(len.usize()) end @X509_NAME_get_text_by_NID( subject, I32(13), common.cstring(), len + 1) common.recalc() if common.size() != len.usize() then error end common fun all_names(cert: Pointer[X509]): Array[String] val => \"\"\" Returns an array of all names for the certificate. Any names containing NULL bytes are not included. This includes the common name and all subject alternate names. \"\"\" let array = recover Array[String] end if cert.is_null() then return array end try array.push(common_name(cert)?) end let stack = @X509_get_ext_d2i(cert, I32(85), Pointer[U8], Pointer[U8]) if stack.is_null() then return array end var name = ifdef \"openssl_1.1.x\" then @OPENSSL_sk_pop(stack) elseif \"openssl_0.9.0\" then @sk_pop(stack) else compile_error \"You must select an SSL version to use.\" end while not name.is_null() do var ptype = I32(0) let value = @GENERAL_NAME_get0_value(name, addressof ptype) match ptype | 2 => // GEN_DNS // Check for V_ASN1_IA5STRING if @ASN1_STRING_type(value) == 22 then try array.push( recover // Build a String from the ASN1 data. let data = @ASN1_STRING_get0_data(value) let len = @ASN1_STRING_length(value) let s = String.copy_cstring(data) // If it contains NULL bytes, don't include it. if s.size() != len.usize() then error end s end) end end | 7 => // GEN_IPADD // Turn the IP address into a string. array.push( recover // Build a String from the ASN1 data. let data = @ASN1_STRING_get0_data(value) let len = @ASN1_STRING_length(value) String.from_cstring(@pony_os_ip_string(data, len)) end) end @GENERAL_NAME_free(name) ifdef \"openssl_1.1.x\" then name = @OPENSSL_sk_pop(stack) elseif \"openssl_0.9.0\" then name = @sk_pop(stack) else compile_error \"You must select an SSL version to use.\" end end ifdef \"openssl_1.1.x\" then @OPENSSL_sk_free(stack) elseif \"openssl_0.9.0\" then @sk_free(stack) else compile_error \"You must select an SSL version to use.\" end array fun _match_name(host: String, name: String): Bool => \"\"\" Returns true if the name extracted from the certificate is valid for the given host. \"\"\" if DNS.is_ip4(host) or DNS.is_ip6(host) then // If the host is a literal IP address, it must match exactly. return host == name end if host.compare_sub(name, name.size(), 0, 0, true) is Equal then // If the names are the same ignoring case, they match. return true end try if name(0)? == '*' then // The name has a wildcard. Must be followed by at least two // non-empty domain levels. if (name.size() < 3) or (name(1)? != '.') or (name(2)? == '.') then return false end try // Find the second domain level and make sure it's followed by // something other than a dot. let offset = name.find(\".\", 3)? if name.at_offset(offset + 1)? == '.' then return false end end // Get the host domain. let domain = host.find(\".\")? // If the host domain is the wildcard domain ignoring case, they match. return host.compare_sub(name, name.size() - 1, domain, 1, true) is Equal end end false","title":"X509"}]}